"use strict";(self.webpackChunkkira_documentation=self.webpackChunkkira_documentation||[]).push([[7831],{7180:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>r,metadata:()=>o,toc:()=>c});var n=a(5893),i=a(1151);a(4866),a(5162);const r={title:"KIRA\u2019s Approach to Data Availability",sidebar_position:1,slug:"/f76e0a61-8dae-4be2-a3f8-bcb49064711f"},s=void 0,o={id:"What-is-KIRA/Middleware---INTERX/KIRA\u2019s-Approach-to-Data-Availability",title:"KIRA\u2019s Approach to Data Availability",description:"Traditional systems often treat all application data uniformly\u2014both user balances and arbitrary data\u2014 a method that compromises UX and practicality. This is particularly true when quick access to essential and trusted information, like user balances, is required during unexpected interruptions in the application\u2019s sequencing process (e.g. requests rate limiting). KIRA addresses this by clearly distinguishing these types of data. Specifically, user balances can be directly settled on SEKAI, KIRA\u2019s base layer, leveraging account abstraction. This arrangement allows Layer 2 applications to be treated similarly to user accounts, enabling them to perform on-chain actions such as issuing tokens, participating in governance, staking, and even communicating with other applications as if they were autonomous humans.",source:"@site/tabs/Learn/What-is-KIRA/Middleware---INTERX/KIRA\u2019s-Approach-to-Data-Availability.mdx",sourceDirName:"What-is-KIRA/Middleware---INTERX",slug:"/f76e0a61-8dae-4be2-a3f8-bcb49064711f",permalink:"/learn/f76e0a61-8dae-4be2-a3f8-bcb49064711f",draft:!1,unlisted:!1,editUrl:"https://github.com/KiraCore/docs.kira.network/issues/new?assignees=&labels=documentation,issue&projects=&template=report_an_issue.yaml&title=%5BISSUE+REPORT%5D&page-github=/learn/f76e0a61-8dae-4be2-a3f8-bcb49064711f&page-local=what-is-kira/middleware---interx/kira\u2019s-approach-to-data-availability.mdx",tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"KIRA\u2019s Approach to Data Availability",sidebar_position:1,slug:"/f76e0a61-8dae-4be2-a3f8-bcb49064711f"},sidebar:"defaultSidebar",previous:{title:"Overview",permalink:"/learn/f15d196e-9520-446e-918f-7f324ce286fe"},next:{title:"Decentralized API Gateway Through Swarm Request",permalink:"/learn/8ae0b973-e6bd-43c2-92f2-50db9e150fd7"}},l={},c=[];function u(e){const t={li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.p,{children:"Traditional systems often treat all application data uniformly\u2014both user balances and arbitrary data\u2014 a method that compromises UX and practicality. This is particularly true when quick access to essential and trusted information, like user balances, is required during unexpected interruptions in the application\u2019s sequencing process (e.g. requests rate limiting). KIRA addresses this by clearly distinguishing these types of data. Specifically, user balances can be directly settled on SEKAI, KIRA\u2019s base layer, leveraging account abstraction. This arrangement allows Layer 2 applications to be treated similarly to user accounts, enabling them to perform on-chain actions such as issuing tokens, participating in governance, staking, and even communicating with other applications as if they were autonomous humans."}),"\n",(0,n.jsx)(t.p,{children:"In managing and ensuring the availability of arbitrary application data, INTERX adopts a specialized implementation designed to enhance the data replication versus network overhead ratio. This implementation is underpinned by four foundational concepts:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Integrated Data Management:"})," Consensus nodes operate and autoscale INTERX containers alongside their RollApp execution containers, akin to how edge nodes function within traditional Web2 networks. An edge node serves as a conduit between local environments (SEKAI and RollApp containers in KIRA\u2019s case) and the external world. In this setup, essential data is directly accessible on the same devices that execute the application, thus reducing latency and the dependency issues seen when DA is handled by an external network."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Dedicated DA Sub-networks"}),": Leveraging its node discovery capabilities, INTERX assigns each RollApp its own firewalled and rate-limited DA 'subnet'. This architecture optimizes bandwidth utilization and resource allocation by reducing the exchange and management of the application\u2019s data only to the nodes directly relevant to the application\u2014namely, its executors and verifiers."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Adaptive Data Replication"}),": Traditional DA systems often employ a one-size-fits-all replication factor. Essentially, they define the level of redundancy through a fixed number of copies distributed within the network to ensure data availability. In practice, however, individual applications have distinct requirements for data access speed and replication based on the data type. With INTERX, RollApp data is replicated based on the individual needs of executors and verifiers. Developers can scale this replication level to align precisely with their application's needs, such as minimum bandwidth utilization for noncritical data and/or maximum possible security for application-critical data."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Caching:"})," INTERX implements a caching mechanism to efficiently manage high-demand scenarios and prevent system overload. This feature is especially important in KIRA, where SEKAI\u2019s block time can be extended based on the number of consensus nodes involved, influencing the likelihood of data being queried multiple times before any updates occur. By storing data after its initial retrieval, INTERX can swiftly respond to duplicate requests, conserving resources required to perform complex queries and thus maintaining network responsiveness."]}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(u,{...e})}):u(e)}},5162:(e,t,a)=>{a.d(t,{Z:()=>s});a(7294);var n=a(6905);const i={tabItem:"tabItem_Ymn6"};var r=a(5893);function s(e){let{children:t,hidden:a,className:s}=e;return(0,r.jsx)("div",{role:"tabpanel",className:(0,n.Z)(i.tabItem,s),hidden:a,children:t})}},4866:(e,t,a)=>{a.d(t,{Z:()=>x});var n=a(7294),i=a(6905),r=a(2466),s=a(6550),o=a(469),l=a(1980),c=a(7392),u=a(12);function d(e){return n.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,n.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function p(e){const{values:t,children:a}=e;return(0,n.useMemo)((()=>{const e=t??function(e){return d(e).map((e=>{let{props:{value:t,label:a,attributes:n,default:i}}=e;return{value:t,label:a,attributes:n,default:i}}))}(a);return function(e){const t=(0,c.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,a])}function h(e){let{value:t,tabValues:a}=e;return a.some((e=>e.value===t))}function b(e){let{queryString:t=!1,groupId:a}=e;const i=(0,s.k6)(),r=function(e){let{queryString:t=!1,groupId:a}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!a)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return a??null}({queryString:t,groupId:a});return[(0,l._X)(r),(0,n.useCallback)((e=>{if(!r)return;const t=new URLSearchParams(i.location.search);t.set(r,e),i.replace({...i.location,search:t.toString()})}),[r,i])]}function m(e){const{defaultValue:t,queryString:a=!1,groupId:i}=e,r=p(e),[s,l]=(0,n.useState)((()=>function(e){let{defaultValue:t,tabValues:a}=e;if(0===a.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!h({value:t,tabValues:a}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${a.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const n=a.find((e=>e.default))??a[0];if(!n)throw new Error("Unexpected error: 0 tabValues");return n.value}({defaultValue:t,tabValues:r}))),[c,d]=b({queryString:a,groupId:i}),[m,f]=function(e){let{groupId:t}=e;const a=function(e){return e?`docusaurus.tab.${e}`:null}(t),[i,r]=(0,u.Nk)(a);return[i,(0,n.useCallback)((e=>{a&&r.set(e)}),[a,r])]}({groupId:i}),g=(()=>{const e=c??m;return h({value:e,tabValues:r})?e:null})();(0,o.Z)((()=>{g&&l(g)}),[g]);return{selectedValue:s,selectValue:(0,n.useCallback)((e=>{if(!h({value:e,tabValues:r}))throw new Error(`Can't select invalid tab value=${e}`);l(e),d(e),f(e)}),[d,f,r]),tabValues:r}}var f=a(2389);const g={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var v=a(5893);function y(e){let{className:t,block:a,selectedValue:n,selectValue:s,tabValues:o}=e;const l=[],{blockElementScrollPositionUntilNextRender:c}=(0,r.o5)(),u=e=>{const t=e.currentTarget,a=l.indexOf(t),i=o[a].value;i!==n&&(c(t),s(i))},d=e=>{let t=null;switch(e.key){case"Enter":u(e);break;case"ArrowRight":{const a=l.indexOf(e.currentTarget)+1;t=l[a]??l[0];break}case"ArrowLeft":{const a=l.indexOf(e.currentTarget)-1;t=l[a]??l[l.length-1];break}}t?.focus()};return(0,v.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":a},t),children:o.map((e=>{let{value:t,label:a,attributes:r}=e;return(0,v.jsx)("li",{role:"tab",tabIndex:n===t?0:-1,"aria-selected":n===t,ref:e=>l.push(e),onKeyDown:d,onClick:u,...r,className:(0,i.Z)("tabs__item",g.tabItem,r?.className,{"tabs__item--active":n===t}),children:a??t},t)}))})}function w(e){let{lazy:t,children:a,selectedValue:i}=e;const r=(Array.isArray(a)?a:[a]).filter(Boolean);if(t){const e=r.find((e=>e.props.value===i));return e?(0,n.cloneElement)(e,{className:"margin-top--md"}):null}return(0,v.jsx)("div",{className:"margin-top--md",children:r.map(((e,t)=>(0,n.cloneElement)(e,{key:t,hidden:e.props.value!==i})))})}function I(e){const t=m(e);return(0,v.jsxs)("div",{className:(0,i.Z)("tabs-container",g.tabList),children:[(0,v.jsx)(y,{...e,...t}),(0,v.jsx)(w,{...e,...t})]})}function x(e){const t=(0,f.Z)();return(0,v.jsx)(I,{...e,children:d(e.children)},String(t))}},1151:(e,t,a)=>{a.d(t,{Z:()=>o,a:()=>s});var n=a(7294);const i={},r=n.createContext(i);function s(e){const t=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),n.createElement(r.Provider,{value:t},e.children)}}}]);