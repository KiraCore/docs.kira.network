"use strict";(self.webpackChunkkira_documentation=self.webpackChunkkira_documentation||[]).push([[5850],{9455:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>l});var n=i(5893),a=i(1151);i(4866),i(5162);const o={title:"Concept",sidebar_position:0,slug:"/concept"},s=void 0,r={id:"backend---sekai/modules/layer-2/concept",title:"Concept",description:"We warmly recommend watching this insightful presentation by our Architect @Asmodat to explore KIRA's unique approach to General-Purpose Rollups.",source:"@site/tabs/docs/backend---sekai/modules/layer-2/concept.mdx",sourceDirName:"backend---sekai/modules/layer-2",slug:"/concept",permalink:"/docs/concept",draft:!1,unlisted:!1,editUrl:"https://github.com/KiraCore/docs.kira.network/issues/new?assignees=&labels=documentation,issue&projects=&template=report_an_issue.yaml&title=%5BISSUE+REPORT%5D&page-github=/docs/concept&page-local=backend---sekai/modules/layer-2/concept.mdx",tags:[],version:"current",sidebarPosition:0,frontMatter:{title:"Concept",sidebar_position:0,slug:"/concept"},sidebar:"defaultSidebar",previous:{title:"Poor Network Conditions",permalink:"/docs/poor-network-conditions"},next:{title:"Concept",permalink:"/docs/concept"}},c={},l=[{value:"High-performance Applications With Blockchain Systems",id:"c1a61da3293b47fc8be61f30843b4138",level:2},{value:"Bandwidth as the Ultimate Bottleneck for Scalability",id:"4ed9e84ec8f94507866852413e4a1535",level:3},{value:"Achieving Scalability Through Rollup-centric Designs",id:"f1b9372da0384fc0921642b1b123a5fb",level:3},{value:"Harnessing the Extensive Capabilities of General-purpose Rollups With KIRA",id:"fd8a84e0adcf44ea91c176afd79b13e6",level:2},{value:"Programmable Finality With the Virtual Finality Gadget",id:"1917dc3082a54cf89c0b46a48df9c45a",level:3},{value:"Achieving True Turing Completeness With Blockchainless Applications",id:"2b03f9dd57104227a3eea4f000fc377e",level:3}];function h(e){const t={a:"a",admonition:"admonition",em:"em",h2:"h2",h3:"h3",img:"img",p:"p",...(0,a.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.admonition,{type:"note",children:(0,n.jsxs)(t.p,{children:["We warmly recommend watching ",(0,n.jsx)(t.a,{href:"https://youtu.be/MsNu8dOzhkY?si=K2V1MSvEavwUf9iv",children:"this insightful presentation"})," by our Architect ",(0,n.jsx)(t.a,{href:"https://twitter.com/asmodat?lang=fr",children:"@Asmodat"})," to explore KIRA's unique approach to General-Purpose Rollups."]})}),"\n",(0,n.jsx)(t.h2,{id:"c1a61da3293b47fc8be61f30843b4138",children:"High-performance Applications With Blockchain Systems"}),"\n",(0,n.jsx)(t.h3,{id:"4ed9e84ec8f94507866852413e4a1535",children:"Bandwidth as the Ultimate Bottleneck for Scalability"}),"\n",(0,n.jsx)(t.p,{children:"Blockchains are specific implementations of the broader concept of verifiable general computation, a principle that ensures the integrity of a computation\u2019s execution without relying on trusted hardware. In a process referred to as consensus, blockchains verify computation through naive re-execution, where multiple computers (nodes) collectively execute the same computation with identical sequence of ordered inputs. These nodes then agree on the output (also referred as the state of the the blockchain application), ensuring it is identical across all nodes. Once consensus is reached, the ordered inputs are batched into so called \u2018block\u2019 and saved (or \u2018chained\u2019) to the blockchain in a way that makes them resistant to re-organization and thus achieving finality. However, while this consensus process guarantees integrity, it also introduces a significant scalability bottleneck: As the number of nodes or the computational workload increases, the time required for all nodes to reach consensus on the outputs grows. Therefore, the maximum achievable throughput (rate of processing transactions) decreases, which ultimately limits the diversity and complexity of applications that can be executed."}),"\n",(0,n.jsx)(t.p,{children:"This scalability issue was initially formulated by Zamfir's impossibility conjecture which posits that no distributed system can simultaneously achieve a high node count (decentralization), fast finality (time required for immutable transaction history post-consensus), and low protocol overhead (necessary data to be transferred for consensus). This hypothesis, while not formally proven, is viewed as a reinterpretation of the CAP theorem. In essence, the consensus is inherently constrained by the hardware performance of the most resource-limited nodes of the supermajority and the fundamental bandwidth limitation: the immutable speed of light, which sets an upper limit to the rate of data transmission over fiber optic cables. While both factors influence the system's performance, the latter presents a more significant long-term challenge. This is because the overhead of the consensus protocol, while increasing linearly with the volume of data, grows exponentially with the number of nodes. This growth happens independently of the hardware capabilities of individual nodes. Thus, if decentralization is a cardinal requirement, bandwidth optimization should be the focus to attaining better performance."}),"\n",(0,n.jsx)(t.h3,{id:"f1b9372da0384fc0921642b1b123a5fb",children:"Achieving Scalability Through Rollup-centric Designs"}),"\n",(0,n.jsxs)(t.p,{children:["In the quest for improved performance, the industry is increasingly adopting the strategy of off-chain execution. These strategies, rooted in the concept of horizontal scalability, aim to boost the system\u2019s throughput by distributing the computational load across 'parallel' chains. While there are many approaches to this technique, they primarily fall into two main categories. Some projects, like Cosmos and Avalanche, have adopted a ",(0,n.jsx)(t.em,{children:"fragmentation"})," approach which involves dividing the system into multiple independent blockchain networks, each with its own consensus mechanism and Consensus nodes. Conversely, other projects like Ethereum and Polkadot, have chosen a ",(0,n.jsx)(t.em,{children:"centric"})," approach. This strategy focuses on maintaining a core \u2018superchain\u2019 (also referred to as the ",(0,n.jsx)(t.em,{children:"Coordination chain"}),", ",(0,n.jsx)(t.em,{children:"Relay Chain"}),", ",(0,n.jsx)(t.em,{children:"Layer 1"}),", or even ",(0,n.jsx)(t.em,{children:"Layer 0"})," depending on the actual architecture) that acts as a single, shared source of finality for all dependent sub-networks (often referred to as ",(0,n.jsx)(t.em,{children:"Layer 2\u2019s"})," or ",(0,n.jsx)(t.em,{children:"Rollups"}),"). We argue that only the second approach provides a compelling solution."]}),"\n",(0,n.jsxs)(t.p,{children:["While the ",(0,n.jsx)(t.em,{children:"fragmentation"})," approach theoretically improves scalability by distributing workload, it works under the assumption that all network states are autonomous. Each state has its own finality, with no source of unified finality across all networks. This, along with the lack of homogenous security among them, stemming from each new network having a different Consensus node set and therefore a different security model, increases systemic risk as more chains are interconnected. Indeed, as observed in practice, the security of one chain often do not match the security of another. This considerably reduces the potential for composability due to the compounding of additional trust assumptions during inter-network interactions. Notably, the deployment of each individual network demands a significant amount of time and resources for developers. And lastly, fragmentation does not optimize for bandwidth since each of these networks requires its own distinct consensus process for finality, which implies that the bandwidth per load remains constant (assuming a constant security level). Therefore, despite all the tradeoffs it introduces, this architecture doesn't really overcome the previously discussed limitations."]}),"\n",(0,n.jsxs)(t.p,{children:["In the ",(0,n.jsx)(t.em,{children:"centric"})," approach however, the consensus of the \u2018superchain\u2019 and the execution of its rollups applications are separated. This allows the chain to focus on providing security and finality without having its consensus burdened by resource-intensive applications. This modularity offers a significant advantage compared to the fragmentation approach since rollups don't need to undergo heavy consensus processes to achieve finality. Instead, they can use various other verification methods that validate the correctness of computations by anchoring themselves in the security and finality provided by the \u2018superchain\u2019. This opens up the opportunity to experiment with different verification methods that don't necessarily depend on large number of operators, have lower time to deployment and enhances cost-efficiency from of bandwidth per load perspective. Most importantly, this flexibility benefits rollups applications as they can customize these methods based on their unique needs and trade-offs."]}),"\n",(0,n.jsx)(t.p,{children:"Taking it a step further, KIRA has devised a unique approach where Consensus nodes also shoulder the responsibility of hosting L2 applications, which includes managing Data Availability (application\u2019s arbitrary data as balances are directly settled on-chain). This considerably reduces the bandwidth requirements as the necessary data to advance the state of the application is physically proximate to the nodes that require it. A stark contrast to classical modular systems where data is shuttled back and forth between various external modular networks such as Data Availability, decentralized Prover or Sequencer chains, that might be geographically far apart, thereby unnecessarily increasing bandwidth usage and inducing latency in the system. In this sense, KIRA embodies a hypermodular network, an architecture that reduces unnecessary overhead, complexity, and dependency risk by ensuring all essential modular components are readily accessible."}),"\n",(0,n.jsx)(t.h2,{id:"fd8a84e0adcf44ea91c176afd79b13e6",children:"Harnessing the Extensive Capabilities of General-purpose Rollups With KIRA"}),"\n",(0,n.jsx)(t.h3,{id:"1917dc3082a54cf89c0b46a48df9c45a",children:"Programmable Finality With the Virtual Finality Gadget"}),"\n",(0,n.jsx)(t.p,{children:'Rollups have significantly advanced blockchain scalability by enabling more powerful and cost-effective decentralized applications. However, the current existing solutions treats execution and verification as inseparable elements. This conflation requires applications to be designed around one specific verification method, such as Optimistic Rollups with fraud proofs or ZK-Rollups with validity proofs. Committing to a single verification scheme limits rollup applications\' adaptability and ability to keep up with evolving verification technologies. They could potentially be tied to a method that becomes outdated or less efficient over time, leading to a possible waste of considerable development time and financial resources. Moreover, the approach substantially restricts the scope of compatible logics, given that rollups are unable to harness the benefits of utilizing diverse methods collectively or interchangeably. The reason behind this limitation is rooted in the nature of general computation where not all code strictly adheres to "logical" and deterministic patterns, hence it cannot be fully verified using a single method. A program may encompass both deterministic and non-deterministic logics, even a Blockchain (e.g. bugs and hacks). Real-life scenarios and code are not always mutually exclusive (e.g. video games), and high-level applications are not impervious to real-world alterations \u2013 Bitcoin being no exception. Rather than being constrained to a single verification scheme, General-Purpose Rollups (decentralized general computation applications) should be able to harness diverse verification methods to express their full potential. For instance, while Risc0 employs validity proofs for computations\u2014a process that can be relatively slow\u2014it should ideally serve as just one component within a larger system. This allows the overarching system to leverage a variety of verification methods tailored for its respective subsystems as necessary, rather than being entirely dependent on the constraints of Risc0.'}),"\n",(0,n.jsx)(t.p,{children:"Building upon the concepts of rollups and the idea of modular execution, KIRA introduces the Verifiable Finality Gadget for its Layer 2 applications (also referred to as RollApps). This approach distinguishes execution and verification as two distinct aspect of a verifiable general computation system. Each RollApp is comprised of a single homogeneous Docker container, which is run by at least one or a group of KIRA\u2019s Consensus nodes, known as Executors. This container operates a virtualized execution environment (application logic). Alongside it, there can be an arbitrary number of heterogeneous verification containers. These are run by both Consensus and non-Consensus nodes, which are referred to as Verifiers, who defines how changes in the application state is being verified (verification logics). This approach originates from the realization that various systems, whether they are blockchains, rollups or others, are fundamentally similar but encounter different constraints due to their unique verification rules (commonly referred to as finality rules). Most importantly, the execution environment is actually agnostic to the nature of these rules, meaning that the execution logic can remain unchanged even as methods of verification evolve. It is even agnostic to the type of hardware components such as GPUs or CPUs needed to perform the execution which implies it isn't limited by the hardware infrastructure of any individual Consensus node, allowing for diverse hardware configurations among different nodes. From customs Virtual Machines to ZK-Rollups, from Web2 applications to Multi-Party Computation Web3 applications, from an AI agent to a video game - any execution environment can be virtualized and verified using VFG. Concurrently, VFG enables the use of any combination of arbitrary methods for defining finality which can even incorporate human authority or non deterministic logic such as AI agents, with adjustments tailored to the specific security needs of the application, computational load, energy efficiency, and bandwidth usage. In essence, modular verification empowers developers to build complexe trustless application with maximum efficiency, and by doing so paves the way for General-Purpose Rollups to exist. Additionally, VFG liberates developers from the pitfalls of being tied to a single method of verification that could potentially become outdated. Just as the Ethereum Virtual Machine was eventually superseded by application-specific chains and rollups, it can be expected that current verification technologies, such as Risc0, might be replaced in the future. This is because in the realm of verifiable general computation, there is not just one solution; there are infinite."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{src:i(2228).Z+"",width:"2720",height:"806"})}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.em,{children:"Finality is a spectrum."})}),"\n",(0,n.jsx)(t.h3,{id:"2b03f9dd57104227a3eea4f000fc377e",children:"Achieving True Turing Completeness With Blockchainless Applications"}),"\n",(0,n.jsxs)(t.p,{children:["In his ",(0,n.jsx)(t.a,{href:"https://graypaper.com/",children:"graypaper"}),", \"JAM\", Gavin Wood, the grandfather of the Ethereum Virtual Machine, identifies five critical properties that decentralized applications platforms must possess: resilience, generality, performance, composability, and accessibility. Among these, generality\u2014defined as the platform's ability to perform Turing-complete computations\u2014is an essential and widely accepted prerequisite for fostering innovation. Interestingly, Wood notes that despite the design of current smart contract platforms to support Turing Completeness, execution is, in fact, bounded.  While these platforms do provide some memory space and a few computation cycles, these resources are quickly exhausted due to the inherent concept of 'gas'. In blockchain systems, 'gas' serves two main roles. It acts as a payment mechanism for memory usage and computation, and serves as a solution to the 'halting problem' by limiting the number of computations executed by a batch of inputs, essentially defining the computational capacity of a single block. This limitation is necessary given that blockchains, as a specific implementation of verifiable computation, rely on the re-execution of each block by a supermajority of nodes within a specified time. Without 'gas', a block generating unrestricted computations would not reach finality, potentially resulting in the halting of the chain's progress. This could occur due to issues like never-ending transaction execution, such as an infinite loops."]}),"\n",(0,n.jsxs)(t.p,{children:["This gas model significantly restricts the type of applications that can be executed \u2018on the blockchain\u2019, as they cannot operate beyond or asynchronously from the limited block\u2019s execution cycles. Despite commendable advancements in block speed or size, the inherent limitations of blockchain systems will always pose a significant hurdle to running complex applications such as AI or games. Blockchains, or as we may aptly term them ",(0,n.jsx)(t.em,{children:"gas-constrained virtual machines"}),", are most suitable for overseeing assets transfers and coordinating metadata around business logic which is the core concept around which SEKAI is designed."]}),"\n",(0,n.jsx)(t.p,{children:"While VFGs offer a pathway for applications to set custom finality rules and move away from typical gas-constrained VMs, their execution remains session-based. This setup requires application builders to instantiate their own virtual machine environments or otherwise define their own state machine rules of execution to address inherent limitations, a task that can be quite complex. This is why the Ethereum VM is frequently reused in the industry, much like Bitcoin was forked to create early altcoins. KIRA provides a solution to these constraints by enabling applications to operate in a blockchainless environment. It allows applications to run asynchronously from its sessions. KIRA achieves this by allowing the applications Executor to continuously submit and update intermediate, non-final state hash (or state snapshots) during an application execution session. The next Executor can then pick up the work in real-time or execute in parallel to the current Executor, enabling the application to operate similarly to classic Web2 apps without being interrupted. Furthermore, non-Multi-Party Computation (MPC) scenarios, where only a single Executor is needed, result in a substantial boost in application performance, pushing the boundaries of what has been achievable to date. In essence, the realization of general-purpose rollups relies on the synergistic combination of the flexible finality rules offered by VFGs and the full expressivity of Blockchainless Applications which, due to their asynchronous capacity, can achieve true Turing completeness."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{src:i(1030).Z+"",width:"2120",height:"1114"})}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.em,{children:"Any execution environment can be made verifiable using VFG, including SEKAI, which might one day evolve into its own Layer 2, eliminating the need for its current consensus mechanism, Tendermint."})})]})}function u(e={}){const{wrapper:t}={...(0,a.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},5162:(e,t,i)=>{i.d(t,{Z:()=>s});i(7294);var n=i(6905);const a={tabItem:"tabItem_Ymn6"};var o=i(5893);function s(e){let{children:t,hidden:i,className:s}=e;return(0,o.jsx)("div",{role:"tabpanel",className:(0,n.Z)(a.tabItem,s),hidden:i,children:t})}},4866:(e,t,i)=>{i.d(t,{Z:()=>k});var n=i(7294),a=i(6905),o=i(2466),s=i(6550),r=i(469),c=i(1980),l=i(7392),h=i(12);function u(e){return n.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,n.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function d(e){const{values:t,children:i}=e;return(0,n.useMemo)((()=>{const e=t??function(e){return u(e).map((e=>{let{props:{value:t,label:i,attributes:n,default:a}}=e;return{value:t,label:i,attributes:n,default:a}}))}(i);return function(e){const t=(0,l.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,i])}function p(e){let{value:t,tabValues:i}=e;return i.some((e=>e.value===t))}function m(e){let{queryString:t=!1,groupId:i}=e;const a=(0,s.k6)(),o=function(e){let{queryString:t=!1,groupId:i}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!i)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return i??null}({queryString:t,groupId:i});return[(0,c._X)(o),(0,n.useCallback)((e=>{if(!o)return;const t=new URLSearchParams(a.location.search);t.set(o,e),a.replace({...a.location,search:t.toString()})}),[o,a])]}function f(e){const{defaultValue:t,queryString:i=!1,groupId:a}=e,o=d(e),[s,c]=(0,n.useState)((()=>function(e){let{defaultValue:t,tabValues:i}=e;if(0===i.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!p({value:t,tabValues:i}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${i.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const n=i.find((e=>e.default))??i[0];if(!n)throw new Error("Unexpected error: 0 tabValues");return n.value}({defaultValue:t,tabValues:o}))),[l,u]=m({queryString:i,groupId:a}),[f,b]=function(e){let{groupId:t}=e;const i=function(e){return e?`docusaurus.tab.${e}`:null}(t),[a,o]=(0,h.Nk)(i);return[a,(0,n.useCallback)((e=>{i&&o.set(e)}),[i,o])]}({groupId:a}),y=(()=>{const e=l??f;return p({value:e,tabValues:o})?e:null})();(0,r.Z)((()=>{y&&c(y)}),[y]);return{selectedValue:s,selectValue:(0,n.useCallback)((e=>{if(!p({value:e,tabValues:o}))throw new Error(`Can't select invalid tab value=${e}`);c(e),u(e),b(e)}),[u,b,o]),tabValues:o}}var b=i(2389);const y={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var g=i(5893);function v(e){let{className:t,block:i,selectedValue:n,selectValue:s,tabValues:r}=e;const c=[],{blockElementScrollPositionUntilNextRender:l}=(0,o.o5)(),h=e=>{const t=e.currentTarget,i=c.indexOf(t),a=r[i].value;a!==n&&(l(t),s(a))},u=e=>{let t=null;switch(e.key){case"Enter":h(e);break;case"ArrowRight":{const i=c.indexOf(e.currentTarget)+1;t=c[i]??c[0];break}case"ArrowLeft":{const i=c.indexOf(e.currentTarget)-1;t=c[i]??c[c.length-1];break}}t?.focus()};return(0,g.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,a.Z)("tabs",{"tabs--block":i},t),children:r.map((e=>{let{value:t,label:i,attributes:o}=e;return(0,g.jsx)("li",{role:"tab",tabIndex:n===t?0:-1,"aria-selected":n===t,ref:e=>c.push(e),onKeyDown:u,onClick:h,...o,className:(0,a.Z)("tabs__item",y.tabItem,o?.className,{"tabs__item--active":n===t}),children:i??t},t)}))})}function w(e){let{lazy:t,children:i,selectedValue:a}=e;const o=(Array.isArray(i)?i:[i]).filter(Boolean);if(t){const e=o.find((e=>e.props.value===a));return e?(0,n.cloneElement)(e,{className:"margin-top--md"}):null}return(0,g.jsx)("div",{className:"margin-top--md",children:o.map(((e,t)=>(0,n.cloneElement)(e,{key:t,hidden:e.props.value!==a})))})}function x(e){const t=f(e);return(0,g.jsxs)("div",{className:(0,a.Z)("tabs-container",y.tabList),children:[(0,g.jsx)(v,{...e,...t}),(0,g.jsx)(w,{...e,...t})]})}function k(e){const t=(0,b.Z)();return(0,g.jsx)(x,{...e,children:u(e.children)},String(t))}},1030:(e,t,i)=>{i.d(t,{Z:()=>n});const n=i.p+"assets/images/1028232594-49d0831ace388c729a32a1c3359a838d.png"},2228:(e,t,i)=>{i.d(t,{Z:()=>n});const n=i.p+"assets/images/247155089-1be9cc62edd78f6dbc82ff810ae13365.png"},1151:(e,t,i)=>{i.d(t,{Z:()=>r,a:()=>s});var n=i(7294);const a={},o=n.createContext(a);function s(e){const t=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),n.createElement(o.Provider,{value:t},e.children)}}}]);