"use strict";(self.webpackChunkkira_documentation=self.webpackChunkkira_documentation||[]).push([[5091],{2356:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>n,toc:()=>u});const n=JSON.parse('{"id":"what-is-kira/middleware---interx/decentralized-api-gateway","title":"Decentralized API Gateway","description":"A distinctive feature of INTERX is its functionality as a decentralized RPC gateway. This capability stems from its unique setup where each INTERX node, regardless of its associated subnet, is linked to a KIRA account address, with all responses being digitally signed. This architecture allows users to query multiple nodes simultaneously and evaluate the responses against each other. Such a mechanism enables users to identify nodes that consistently deliver precise responses and craft off-chain fraud proofs against nodes disseminating fraudulent or inconsistent data.","source":"@site/tabs/learn/what-is-kira/middleware---interx/decentralized-api-gateway.mdx","sourceDirName":"what-is-kira/middleware---interx","slug":"/what-is-kira/middleware---interx/decentralized-api-gateway","permalink":"/learn/what-is-kira/middleware---interx/decentralized-api-gateway","draft":false,"unlisted":false,"editUrl":"https://github.com/KiraCore/docs.kira.network/issues/new?assignees=&labels=documentation,issue&projects=&template=report_an_issue.yaml&title=%5BISSUE+REPORT%5D&page-github=/learn/what-is-kira/middleware---interx/decentralized-api-gateway&page-local=what-is-kira/middleware---interx/decentralized-api-gateway.mdx","tags":[],"version":"current","lastUpdatedAt":1716175504000,"sidebarPosition":2,"frontMatter":{"title":"Decentralized API Gateway","sidebar_position":2,"slug":"decentralized-api-gateway"},"sidebar":"defaultSidebar","previous":{"title":"KIRA\u2019s Approach to Data Availability","permalink":"/learn/what-is-kira/middleware---interx/kiras-approach-to-data-availability"},"next":{"title":"Frontend - MIRO","permalink":"/learn/what-is-kira/frontend---miro"}}');var r=a(4848),s=a(8453);a(5537),a(9329);const i={title:"Decentralized API Gateway",sidebar_position:2,slug:"decentralized-api-gateway"},o=void 0,l={},u=[];function c(e){const t={p:"p",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.p,{children:"A distinctive feature of INTERX is its functionality as a decentralized RPC gateway. This capability stems from its unique setup where each INTERX node, regardless of its associated subnet, is linked to a KIRA account address, with all responses being digitally signed. This architecture allows users to query multiple nodes simultaneously and evaluate the responses against each other. Such a mechanism enables users to identify nodes that consistently deliver precise responses and craft off-chain fraud proofs against nodes disseminating fraudulent or inconsistent data."}),"\n",(0,r.jsx)(t.p,{children:"While light clients theoretically offer higher security through block-by-block consensus verification (without storing data), they fall short due to the maintenance they require. This maintenance challenge becomes particularly pronounced across hundreds or thousands of applications in a growing multi-chain world. By enabling the creation of fraud proofs, INTERX introduces a practical alternative for decentralization. It establishes a balance between the security offered by light clients and the convenience of Infura-style RPC providers. Through repeated queries to a broad spectrum of INTERX nodes, users can achieve a level of security comparable to that of light clients, assuming these nodes are either verified through the Identity Registrar or have stakes involved. This system underscores that even a single honest INTERX node in the query batch can trigger the eviction or slashing of dishonest ones. However, for maximum safety, users are recommended to operate their own INTERX node as well as a SEKAI instance, essentially running a full node."})]})}function d(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},9329:(e,t,a)=>{a.d(t,{A:()=>i});a(6540);var n=a(8215);const r={tabItem:"tabItem_Ymn6"};var s=a(4848);function i(e){let{children:t,hidden:a,className:i}=e;return(0,s.jsx)("div",{role:"tabpanel",className:(0,n.A)(r.tabItem,i),hidden:a,children:t})}},5537:(e,t,a)=>{a.d(t,{A:()=>k});var n=a(6540),r=a(8215),s=a(5627),i=a(6347),o=a(372),l=a(604),u=a(1861),c=a(8749);function d(e){return n.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,n.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function h(e){const{values:t,children:a}=e;return(0,n.useMemo)((()=>{const e=t??function(e){return d(e).map((e=>{let{props:{value:t,label:a,attributes:n,default:r}}=e;return{value:t,label:a,attributes:n,default:r}}))}(a);return function(e){const t=(0,u.XI)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,a])}function f(e){let{value:t,tabValues:a}=e;return a.some((e=>e.value===t))}function p(e){let{queryString:t=!1,groupId:a}=e;const r=(0,i.W6)(),s=function(e){let{queryString:t=!1,groupId:a}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!a)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return a??null}({queryString:t,groupId:a});return[(0,l.aZ)(s),(0,n.useCallback)((e=>{if(!s)return;const t=new URLSearchParams(r.location.search);t.set(s,e),r.replace({...r.location,search:t.toString()})}),[s,r])]}function m(e){const{defaultValue:t,queryString:a=!1,groupId:r}=e,s=h(e),[i,l]=(0,n.useState)((()=>function(e){let{defaultValue:t,tabValues:a}=e;if(0===a.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!f({value:t,tabValues:a}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${a.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const n=a.find((e=>e.default))??a[0];if(!n)throw new Error("Unexpected error: 0 tabValues");return n.value}({defaultValue:t,tabValues:s}))),[u,d]=p({queryString:a,groupId:r}),[m,b]=function(e){let{groupId:t}=e;const a=function(e){return e?`docusaurus.tab.${e}`:null}(t),[r,s]=(0,c.Dv)(a);return[r,(0,n.useCallback)((e=>{a&&s.set(e)}),[a,s])]}({groupId:r}),g=(()=>{const e=u??m;return f({value:e,tabValues:s})?e:null})();(0,o.A)((()=>{g&&l(g)}),[g]);return{selectedValue:i,selectValue:(0,n.useCallback)((e=>{if(!f({value:e,tabValues:s}))throw new Error(`Can't select invalid tab value=${e}`);l(e),d(e),b(e)}),[d,b,s]),tabValues:s}}var b=a(9136);const g={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var y=a(4848);function v(e){let{className:t,block:a,selectedValue:n,selectValue:i,tabValues:o}=e;const l=[],{blockElementScrollPositionUntilNextRender:u}=(0,s.a_)(),c=e=>{const t=e.currentTarget,a=l.indexOf(t),r=o[a].value;r!==n&&(u(t),i(r))},d=e=>{let t=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const a=l.indexOf(e.currentTarget)+1;t=l[a]??l[0];break}case"ArrowLeft":{const a=l.indexOf(e.currentTarget)-1;t=l[a]??l[l.length-1];break}}t?.focus()};return(0,y.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.A)("tabs",{"tabs--block":a},t),children:o.map((e=>{let{value:t,label:a,attributes:s}=e;return(0,y.jsx)("li",{role:"tab",tabIndex:n===t?0:-1,"aria-selected":n===t,ref:e=>{l.push(e)},onKeyDown:d,onClick:c,...s,className:(0,r.A)("tabs__item",g.tabItem,s?.className,{"tabs__item--active":n===t}),children:a??t},t)}))})}function w(e){let{lazy:t,children:a,selectedValue:s}=e;const i=(Array.isArray(a)?a:[a]).filter(Boolean);if(t){const e=i.find((e=>e.props.value===s));return e?(0,n.cloneElement)(e,{className:(0,r.A)("margin-top--md",e.props.className)}):null}return(0,y.jsx)("div",{className:"margin-top--md",children:i.map(((e,t)=>(0,n.cloneElement)(e,{key:t,hidden:e.props.value!==s})))})}function I(e){const t=m(e);return(0,y.jsxs)("div",{className:(0,r.A)("tabs-container",g.tabList),children:[(0,y.jsx)(v,{...t,...e}),(0,y.jsx)(w,{...t,...e})]})}function k(e){const t=(0,b.A)();return(0,y.jsx)(I,{...e,children:d(e.children)},String(t))}},8453:(e,t,a)=>{a.d(t,{R:()=>i,x:()=>o});var n=a(6540);const r={},s=n.createContext(r);function i(e){const t=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);