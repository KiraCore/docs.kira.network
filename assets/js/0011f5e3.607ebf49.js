"use strict";(self.webpackChunkkira_documentation=self.webpackChunkkira_documentation||[]).push([[7155],{719:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var a=t(5893),i=t(1151);t(4866),t(5162);const o={title:"Governance",sidebar_position:2,slug:"governance"},r=void 0,s={id:"what-is-kira/backend---sekai/governance",title:"Governance",description:"KIRA introduces a governance system that fundamentally departs from the conventional stake-weighted voting mechanisms prevalent in blockchain networks. Instead, it adopts a per-capita approach, ensuring that every vote carries equal weight, irrespective of the voter's stake. Within this system, Consensus nodes hold a foundational role by serving as the primary decision-makers. They form the initial group of Councilors, which defines any network participants endowed with the right to propose and vote on network decisions. Anyone can become a Councilor; the group is open to all users, contingent upon receiving endorsement from the existing council.",source:"@site/tabs/learn/what-is-kira/backend---sekai/governance.mdx",sourceDirName:"what-is-kira/backend---sekai",slug:"/what-is-kira/backend---sekai/governance",permalink:"/learn/what-is-kira/backend---sekai/governance",draft:!1,unlisted:!1,editUrl:"https://github.com/KiraCore/docs.kira.network/issues/new?assignees=&labels=documentation,issue&projects=&template=report_an_issue.yaml&title=%5BISSUE+REPORT%5D&page-github=/learn/what-is-kira/backend---sekai/governance&page-local=what-is-kira/backend---sekai/governance.mdx",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"Governance",sidebar_position:2,slug:"governance"},sidebar:"defaultSidebar",previous:{title:"Consensus",permalink:"/learn/what-is-kira/backend---sekai/consensus"},next:{title:"Overview",permalink:"/learn/what-is-kira/middleware---interx/overview"}},l={},c=[{value:"Roles &amp; Permissions",id:"4a92d1418ae641c7aae19bdb862b6ead",level:2},{value:"Governance Structure",id:"3c994110ecf44f89ab62ecadfe43b8a8",level:2},{value:"Decision-making Framework",id:"97310261cd6643c59e08f59fa9662fe1",level:2}];function u(e){const n={h2:"h2",p:"p",...(0,i.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"KIRA introduces a governance system that fundamentally departs from the conventional stake-weighted voting mechanisms prevalent in blockchain networks. Instead, it adopts a per-capita approach, ensuring that every vote carries equal weight, irrespective of the voter's stake. Within this system, Consensus nodes hold a foundational role by serving as the primary decision-makers. They form the initial group of Councilors, which defines any network participants endowed with the right to propose and vote on network decisions. Anyone can become a Councilor; the group is open to all users, contingent upon receiving endorsement from the existing council."}),"\n",(0,a.jsx)(n.h2,{id:"4a92d1418ae641c7aae19bdb862b6ead",children:"Roles & Permissions"}),"\n",(0,a.jsx)(n.p,{children:"KIRA's governance structure is underpinned by a detailed system of permissions, where specific actions, such as voting and proposing, are tied to unique permissions. These permissions dictate whether an account can execute a specific transaction. This granularity in permissions serves as the building blocks for 'roles,' which bundle permissions into comprehensive profiles that define the capabilities and responsibilities of subsets of council members. Being assigned a role equates to having all the permissions it encompasses. Roles, by their nature, are constructs of governance; the only pre-defined role in KIRA is that of \u2018validator\u2019 automatically given to Consensus nodes. All other roles are conceptualized and established through governance actions. The creation of new roles is initiated at the network's inception by Consensus nodes, who use their permissions to propose and approve the establishment of these roles through governance proposals."}),"\n",(0,a.jsx)(n.h2,{id:"3c994110ecf44f89ab62ecadfe43b8a8",children:"Governance Structure"}),"\n",(0,a.jsx)(n.p,{children:"KIRA's governance is inherently flexible and designed to evolve organically within its decentralized framework. Starting with the principle that each Consensus node possesses equal voting power (per capita), they form the cornerstone of governance. They have the autonomy to delegate various governance responsibilities to other verified groups through the definition of roles. This could lead to a dynamic where one group may have certain authority over another, and vice versa, depending on the distribution of responsibilities related to matters such as proposal voting or the management of malicious activities within the network. The governance model's modular design facilitates customized configurations, including multicameral systems for specialized proposal handling and checks and balances to mitigate centralization risks. This adaptability ensures KIRA's governance can evolve to meet diverse network conditions and requirements, underlining the network's capacity for self-directed evolution without centralized oversight."}),"\n",(0,a.jsx)(n.h2,{id:"97310261cd6643c59e08f59fa9662fe1",children:"Decision-making Framework"}),"\n",(0,a.jsx)(n.p,{children:"KIRA governance decisions are voted on-chain to immutably record outcomes on the blockchain itself. However, discussions primarily take place through off-chain coordination amongst Councilors and community members. When a proposal is created, only Councilors can vote if they have the required permission. A proposal passes if over 50% of votes are 'yes', otherwise it is rejected. A minority veto rejection is also possible if over 33.4% of all votes are 'veto\u2019. Proposals require a quorum of 33% to be valid to reflect adequate Councilor participation and representation. If quorum is not reached, the proposal fails. After the voting period ends, there is a defined enactment time before changes take effect, allowing the community to prepare for the outcome. The minimum enactment time is configured by governance and applies to all proposals. Governance can additionally configure different voting periods for individual proposals. This structured on-chain process enables transparent and definitive decision-making."}),"\n",(0,a.jsx)(n.p,{children:"KIRA does not utilize on-chain signaling proposals, which commonly lead to inefficient binary outcomes that fail to capture nuanced perspectives. Instead, it offers on-chain Polls to efficiently gauge sentiment and build consensus on complex issues. Polls allow for multiple customized voting options that cater to the diverse views within the community. This flexibility makes them well-suited for achieving consensus on matters like upgrade timeframes, future protocol changes, and other key issues. The Poll module provides an inclusive signaling mechanism that complements off-chain discussion. Ultimately, Polls enable KIRA's governance to reach timely decisions informed by the authentic and varied opinions of participants."})]})}function d(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(u,{...e})}):u(e)}},5162:(e,n,t)=>{t.d(n,{Z:()=>r});t(7294);var a=t(6905);const i={tabItem:"tabItem_Ymn6"};var o=t(5893);function r(e){let{children:n,hidden:t,className:r}=e;return(0,o.jsx)("div",{role:"tabpanel",className:(0,a.Z)(i.tabItem,r),hidden:t,children:n})}},4866:(e,n,t)=>{t.d(n,{Z:()=>x});var a=t(7294),i=t(6905),o=t(2466),r=t(6550),s=t(469),l=t(1980),c=t(7392),u=t(12);function d(e){return a.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,a.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function h(e){const{values:n,children:t}=e;return(0,a.useMemo)((()=>{const e=n??function(e){return d(e).map((e=>{let{props:{value:n,label:t,attributes:a,default:i}}=e;return{value:n,label:t,attributes:a,default:i}}))}(t);return function(e){const n=(0,c.l)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function p(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function m(e){let{queryString:n=!1,groupId:t}=e;const i=(0,r.k6)(),o=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:n,groupId:t});return[(0,l._X)(o),(0,a.useCallback)((e=>{if(!o)return;const n=new URLSearchParams(i.location.search);n.set(o,e),i.replace({...i.location,search:n.toString()})}),[o,i])]}function f(e){const{defaultValue:n,queryString:t=!1,groupId:i}=e,o=h(e),[r,l]=(0,a.useState)((()=>function(e){let{defaultValue:n,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!p({value:n,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const a=t.find((e=>e.default))??t[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:n,tabValues:o}))),[c,d]=m({queryString:t,groupId:i}),[f,v]=function(e){let{groupId:n}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(n),[i,o]=(0,u.Nk)(t);return[i,(0,a.useCallback)((e=>{t&&o.set(e)}),[t,o])]}({groupId:i}),g=(()=>{const e=c??f;return p({value:e,tabValues:o})?e:null})();(0,s.Z)((()=>{g&&l(g)}),[g]);return{selectedValue:r,selectValue:(0,a.useCallback)((e=>{if(!p({value:e,tabValues:o}))throw new Error(`Can't select invalid tab value=${e}`);l(e),d(e),v(e)}),[d,v,o]),tabValues:o}}var v=t(2389);const g={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var b=t(5893);function k(e){let{className:n,block:t,selectedValue:a,selectValue:r,tabValues:s}=e;const l=[],{blockElementScrollPositionUntilNextRender:c}=(0,o.o5)(),u=e=>{const n=e.currentTarget,t=l.indexOf(n),i=s[t].value;i!==a&&(c(n),r(i))},d=e=>{let n=null;switch(e.key){case"Enter":u(e);break;case"ArrowRight":{const t=l.indexOf(e.currentTarget)+1;n=l[t]??l[0];break}case"ArrowLeft":{const t=l.indexOf(e.currentTarget)-1;n=l[t]??l[l.length-1];break}}n?.focus()};return(0,b.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":t},n),children:s.map((e=>{let{value:n,label:t,attributes:o}=e;return(0,b.jsx)("li",{role:"tab",tabIndex:a===n?0:-1,"aria-selected":a===n,ref:e=>l.push(e),onKeyDown:d,onClick:u,...o,className:(0,i.Z)("tabs__item",g.tabItem,o?.className,{"tabs__item--active":a===n}),children:t??n},n)}))})}function y(e){let{lazy:n,children:t,selectedValue:i}=e;const o=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=o.find((e=>e.props.value===i));return e?(0,a.cloneElement)(e,{className:"margin-top--md"}):null}return(0,b.jsx)("div",{className:"margin-top--md",children:o.map(((e,n)=>(0,a.cloneElement)(e,{key:n,hidden:e.props.value!==i})))})}function w(e){const n=f(e);return(0,b.jsxs)("div",{className:(0,i.Z)("tabs-container",g.tabList),children:[(0,b.jsx)(k,{...e,...n}),(0,b.jsx)(y,{...e,...n})]})}function x(e){const n=(0,v.Z)();return(0,b.jsx)(w,{...e,children:d(e.children)},String(n))}},1151:(e,n,t)=>{t.d(n,{Z:()=>s,a:()=>r});var a=t(7294);const i={},o=a.createContext(i);function r(e){const n=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),a.createElement(o.Provider,{value:n},e.children)}}}]);