"use strict";(self.webpackChunkkira_documentation=self.webpackChunkkira_documentation||[]).push([[2366],{5314:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>r,metadata:()=>o,toc:()=>c});var a=n(5893),s=n(1151);n(4866),n(5162);const r={title:"Overview",sidebar_position:0,slug:"/e26c8757-2bfc-4ec1-add5-4dc82d170e50"},i=void 0,o={id:"Backend---SEKAI/Modules-&-CLI/Modules/Slashing/Overview",title:"Overview",description:'Slashing is a mechanism traditionally used in permissionless Proof-of-Stake networks to address Sybil vulnerabilities and align operator incentives with the network (for more details, see the Consensus page). However, coupling the weighted voting mechanism with strong slashing requirements still does not guarantee that the intentions of these entities align with the long-term best interests of the network. This issue stems from the fundamental limitations of permissionless systems that rely on assumptions about the rationality of participants, which is inherently insecure. The core idea is that rationality-based security models are insufficient in open, permissionless systems because they do not account for the possibility of rational actors exploiting the system for external gains, making the system vulnerable to a broader range of attacks beyond what is considered within the rationality framework. This concern becomes even more pressing as we shift towards a multi-chain "Internet of Blockchains" paradigm.',source:"@site/tabs/Docs/Backend---SEKAI/Modules-&-CLI/Modules/Slashing/Overview.mdx",sourceDirName:"Backend---SEKAI/Modules-&-CLI/Modules/Slashing",slug:"/e26c8757-2bfc-4ec1-add5-4dc82d170e50",permalink:"/docs/e26c8757-2bfc-4ec1-add5-4dc82d170e50",draft:!1,unlisted:!1,editUrl:"https://github.com/KiraCore/docs.kira.network/issues/new?assignees=&labels=documentation,issue&projects=&template=report_an_issue.yaml&title=%5BISSUE+REPORT%5D&page-github=/docs/e26c8757-2bfc-4ec1-add5-4dc82d170e50&page-local=backend---sekai/modules-&-cli/modules/slashing/overview.mdx",tags:[],version:"current",lastUpdatedAt:1711894334,formattedLastUpdatedAt:"Mar 31, 2024",sidebarPosition:0,frontMatter:{title:"Overview",sidebar_position:0,slug:"/e26c8757-2bfc-4ec1-add5-4dc82d170e50"},sidebar:"defaultSidebar",previous:{title:"Slashing",permalink:"/docs/d6fee8b3-1948-493e-bbdd-796bcc996c2b"},next:{title:"Consensus ranks & statuses",permalink:"/docs/9f763be9-fbd3-452f-8c6e-6e418f34856f"}},l={},c=[];function u(e){const t={a:"a",p:"p",...(0,s.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(t.p,{children:["Slashing is a mechanism traditionally used in permissionless Proof-of-Stake networks to address Sybil vulnerabilities and align operator incentives with the network (for more details, see the ",(0,a.jsx)(t.a,{href:"https://claude.ai/chat/link-to-consensus-page",children:"Consensus"})," page). However, coupling the weighted voting mechanism with strong slashing requirements still does not guarantee that the intentions of these entities align with the long-term best interests of the network. This issue stems from ",(0,a.jsx)(t.a,{href:"https://bford.info/2019/09/23/rational/",children:"the fundamental limitations of permissionless systems"}),' that rely on assumptions about the rationality of participants, which is inherently insecure. The core idea is that rationality-based security models are insufficient in open, permissionless systems because they do not account for the possibility of rational actors exploiting the system for external gains, making the system vulnerable to a broader range of attacks beyond what is considered within the rationality framework. This concern becomes even more pressing as we shift towards a multi-chain "Internet of Blockchains" paradigm.']}),"\n",(0,a.jsx)(t.p,{children:"Moreover, slashing mechanisms not only heighten the risk for smaller, home-based node operators, who may worry about incurring severe financial penalties for honest mistakes or system failures, but they also amplify risk for delegators. This dual effect fosters centralizing tendencies: it compels node operators to gravitate towards more centralized, potentially safer cloud services like AWS, and simultaneously, it nudges delegators towards these seemingly more secure nodes for their asset protection. Such shifts inadvertently challenge the decentralized ethos at the heart of blockchain networks, creating a counterproductive dynamic in the ecosystem."}),"\n",(0,a.jsx)(t.p,{children:"KIRA takes a unique stance on slashing. In KIRA's governance-permissioned validator set, the discretionary power of identified governance members to remove malicious nodes enables the detection and mitigation of irrational, malicious behavior that might elude purely economic models. This allows for a more targeted approach to slashing, where only instances of double-signing are subject to potential penalties. These penalties are triggered automatically only when a certain number of validators are caught double-signing within a short time frame, serving as a deterrent against coordinated attacks. In all other cases, slashing is subject to governance approval. This approach minimizes the risk of severe consequences for minor or unintentional errors, reducing the fear of harsh penalties and encouraging a more diverse set of individuals to run validator nodes, including those operating from home environments. Furthermore, it alleviates the pressure on Delegators to prioritize security over decentralization when choosing nodes to stake with, as the network itself is designed to be resilient to a wider range of failures. The combination of automatic slashing under specific conditions, governance-supported slashing for individual cases, and the absence of downtime slashing makes it extremely unlikely for Consensus nodes and Delegators to face unwarranted penalties. This approach aligns more closely with Byzantine principles, as it takes into account the inevitability of human error and system failures, thus promoting a strong, diverse validator community and a more decentralized network overall."})]})}function d(e={}){const{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(u,{...e})}):u(e)}},5162:(e,t,n)=>{n.d(t,{Z:()=>i});n(7294);var a=n(6905);const s={tabItem:"tabItem_Ymn6"};var r=n(5893);function i(e){let{children:t,hidden:n,className:i}=e;return(0,r.jsx)("div",{role:"tabpanel",className:(0,a.Z)(s.tabItem,i),hidden:n,children:t})}},4866:(e,t,n)=>{n.d(t,{Z:()=>x});var a=n(7294),s=n(6905),r=n(2466),i=n(6550),o=n(469),l=n(1980),c=n(7392),u=n(12);function d(e){return a.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,a.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function h(e){const{values:t,children:n}=e;return(0,a.useMemo)((()=>{const e=t??function(e){return d(e).map((e=>{let{props:{value:t,label:n,attributes:a,default:s}}=e;return{value:t,label:n,attributes:a,default:s}}))}(n);return function(e){const t=(0,c.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function m(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function f(e){let{queryString:t=!1,groupId:n}=e;const s=(0,i.k6)(),r=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,l._X)(r),(0,a.useCallback)((e=>{if(!r)return;const t=new URLSearchParams(s.location.search);t.set(r,e),s.replace({...s.location,search:t.toString()})}),[r,s])]}function p(e){const{defaultValue:t,queryString:n=!1,groupId:s}=e,r=h(e),[i,l]=(0,a.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!m({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const a=n.find((e=>e.default))??n[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:t,tabValues:r}))),[c,d]=f({queryString:n,groupId:s}),[p,g]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[s,r]=(0,u.Nk)(n);return[s,(0,a.useCallback)((e=>{n&&r.set(e)}),[n,r])]}({groupId:s}),b=(()=>{const e=c??p;return m({value:e,tabValues:r})?e:null})();(0,o.Z)((()=>{b&&l(b)}),[b]);return{selectedValue:i,selectValue:(0,a.useCallback)((e=>{if(!m({value:e,tabValues:r}))throw new Error(`Can't select invalid tab value=${e}`);l(e),d(e),g(e)}),[d,g,r]),tabValues:r}}var g=n(2389);const b={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var v=n(5893);function y(e){let{className:t,block:n,selectedValue:a,selectValue:i,tabValues:o}=e;const l=[],{blockElementScrollPositionUntilNextRender:c}=(0,r.o5)(),u=e=>{const t=e.currentTarget,n=l.indexOf(t),s=o[n].value;s!==a&&(c(t),i(s))},d=e=>{let t=null;switch(e.key){case"Enter":u(e);break;case"ArrowRight":{const n=l.indexOf(e.currentTarget)+1;t=l[n]??l[0];break}case"ArrowLeft":{const n=l.indexOf(e.currentTarget)-1;t=l[n]??l[l.length-1];break}}t?.focus()};return(0,v.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.Z)("tabs",{"tabs--block":n},t),children:o.map((e=>{let{value:t,label:n,attributes:r}=e;return(0,v.jsx)("li",{role:"tab",tabIndex:a===t?0:-1,"aria-selected":a===t,ref:e=>l.push(e),onKeyDown:d,onClick:u,...r,className:(0,s.Z)("tabs__item",b.tabItem,r?.className,{"tabs__item--active":a===t}),children:n??t},t)}))})}function w(e){let{lazy:t,children:n,selectedValue:s}=e;const r=(Array.isArray(n)?n:[n]).filter(Boolean);if(t){const e=r.find((e=>e.props.value===s));return e?(0,a.cloneElement)(e,{className:"margin-top--md"}):null}return(0,v.jsx)("div",{className:"margin-top--md",children:r.map(((e,t)=>(0,a.cloneElement)(e,{key:t,hidden:e.props.value!==s})))})}function k(e){const t=p(e);return(0,v.jsxs)("div",{className:(0,s.Z)("tabs-container",b.tabList),children:[(0,v.jsx)(y,{...e,...t}),(0,v.jsx)(w,{...e,...t})]})}function x(e){const t=(0,g.Z)();return(0,v.jsx)(k,{...e,children:d(e.children)},String(t))}},1151:(e,t,n)=>{n.d(t,{Z:()=>o,a:()=>i});var a=n(7294);const s={},r=a.createContext(s);function i(e){const t=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),a.createElement(r.Provider,{value:t},e.children)}}}]);