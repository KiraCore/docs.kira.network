"use strict";(self.webpackChunkkira_documentation=self.webpackChunkkira_documentation||[]).push([[6390],{2130:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var a=n(4848),r=n(8453);n(1470),n(9365);const i={title:"Overview",sidebar_position:0,slug:"overview"},s=void 0,o={id:"kira\u2019s-economics/overview",title:"Overview",description:"KIRA's economics are designed to attract and retain a robust network of operators through strategic incentives, rewarding Controllers, Executors, and Verifiers who provide essential infrastructure and services for RollApps. Central to KIRA's economic architecture are several key mechanisms: the native token, KEX, facilitating transactions and governance; Multi-Bonded Proof of Stake, enabling diverse crypto asset staking; the Initial Liquidity Offering for bootstrapping RollApp liquidity at launch; and tailored economic policies fostering sustainable growth. These components work synergistically to create a dynamic, resilient economy that adapts to the evolving needs of KIRA\u2019s users and the broader blockchain landscape.",source:"@site/tabs/learn/kira\u2019s-economics/overview.mdx",sourceDirName:"kira\u2019s-economics",slug:"/kira\u2019s-economics/overview",permalink:"/learn/kira\u2019s-economics/overview",draft:!1,unlisted:!1,editUrl:"https://github.com/KiraCore/docs.kira.network/issues/new?assignees=&labels=documentation,issue&projects=&template=report_an_issue.yaml&title=%5BISSUE+REPORT%5D&page-github=/learn/kira\u2019s-economics/overview&page-local=kira\u2019s-economics/overview.mdx",tags:[],version:"current",lastUpdatedAt:1727071398e3,sidebarPosition:0,frontMatter:{title:"Overview",sidebar_position:0,slug:"overview"},sidebar:"defaultSidebar",previous:{title:"Building on KIRA",permalink:"/learn/what-is-kira/layer-2/building-on-kira"},next:{title:"KEX, KIRA\u2019s Native Token",permalink:"/learn/kira\u2019s-economics/kex-kiras-native-token"}},l={},c=[];function u(e){const t={li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.p,{children:"KIRA's economics are designed to attract and retain a robust network of operators through strategic incentives, rewarding Controllers, Executors, and Verifiers who provide essential infrastructure and services for RollApps. Central to KIRA's economic architecture are several key mechanisms: the native token, KEX, facilitating transactions and governance; Multi-Bonded Proof of Stake, enabling diverse crypto asset staking; the Initial Liquidity Offering for bootstrapping RollApp liquidity at launch; and tailored economic policies fostering sustainable growth. These components work synergistically to create a dynamic, resilient economy that adapts to the evolving needs of KIRA\u2019s users and the broader blockchain landscape."}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Multi-Bonded Proof of Stake (MBPoS):"})," MBPoS is a staking mechanism in SEKAI enhance the network's security and stability in a multi-chain ecosystem. Unlike typical Proof-of-Stake models, it allows a wide range of digital assets to be used as staking collateral. These include native KIRA network assets, non-native assets from other blockchain networks (such as BTC and ETH), NFTs, RWAs, LP tokens, and stablecoins\u2014all subject to governance approval. This multi-asset approach bolsters network security, particularly in scenarios where highly-valued assets from external networks might incentivize KIRA Consensus nodes to act maliciously."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Native Liquid Staking (LSDs)"}),": In addition to MBPoS, KIRA natively issues liquid staking derivatives for all staked assets. These LSDs incentivize users to bridge their tokens by keeping assets liquid, a key pain point in DeFi. This approach enhances capital efficiency and fosters greater participation across KIRA's ecosystem."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Initial Liquidity Offering (ILO):"})," The ILO on KIRA is an innovative mechanism that helps RollApps bootstrap initial liquidity, aligns incentives among stakeholders, enables flexible token economics, and ensures healthy RollApp functionality to foster a thriving ecosystem.  Through a governance proposal process, stakeholders commit KEX to show interest in supporting the RollApp. This KEX is then pooled in a liquidity pool based on a Uniswap-style automated market maker, resulting in the issuance of LP tokens. These tokens are distributed to participants who become LPs, and can be subject to vesting periods. An important requirement is that LPs must maintain the liquidity pool above a specified threshold, as RollApp execution may halt if the pool falls below this level. This incentive-driven strategy aims to ensure sufficient and sustained liquidity for RollApps and aligns Controllers, users, Verifiers, and Executors in a unified effort towards their application's success."]}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(u,{...e})}):u(e)}},9365:(e,t,n)=>{n.d(t,{A:()=>s});n(6540);var a=n(8215);const r={tabItem:"tabItem_Ymn6"};var i=n(4848);function s(e){let{children:t,hidden:n,className:s}=e;return(0,i.jsx)("div",{role:"tabpanel",className:(0,a.A)(r.tabItem,s),hidden:n,children:t})}},1470:(e,t,n)=>{n.d(t,{A:()=>x});var a=n(6540),r=n(8215),i=n(3104),s=n(6347),o=n(205),l=n(7485),c=n(1682),u=n(679);function d(e){return a.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,a.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function p(e){const{values:t,children:n}=e;return(0,a.useMemo)((()=>{const e=t??function(e){return d(e).map((e=>{let{props:{value:t,label:n,attributes:a,default:r}}=e;return{value:t,label:n,attributes:a,default:r}}))}(n);return function(e){const t=(0,c.X)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function h(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function f(e){let{queryString:t=!1,groupId:n}=e;const r=(0,s.W6)(),i=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,l.aZ)(i),(0,a.useCallback)((e=>{if(!i)return;const t=new URLSearchParams(r.location.search);t.set(i,e),r.replace({...r.location,search:t.toString()})}),[i,r])]}function m(e){const{defaultValue:t,queryString:n=!1,groupId:r}=e,i=p(e),[s,l]=(0,a.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!h({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const a=n.find((e=>e.default))??n[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:t,tabValues:i}))),[c,d]=f({queryString:n,groupId:r}),[m,v]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[r,i]=(0,u.Dv)(n);return[r,(0,a.useCallback)((e=>{n&&i.set(e)}),[n,i])]}({groupId:r}),b=(()=>{const e=c??m;return h({value:e,tabValues:i})?e:null})();(0,o.A)((()=>{b&&l(b)}),[b]);return{selectedValue:s,selectValue:(0,a.useCallback)((e=>{if(!h({value:e,tabValues:i}))throw new Error(`Can't select invalid tab value=${e}`);l(e),d(e),v(e)}),[d,v,i]),tabValues:i}}var v=n(2303);const b={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var g=n(4848);function k(e){let{className:t,block:n,selectedValue:a,selectValue:s,tabValues:o}=e;const l=[],{blockElementScrollPositionUntilNextRender:c}=(0,i.a_)(),u=e=>{const t=e.currentTarget,n=l.indexOf(t),r=o[n].value;r!==a&&(c(t),s(r))},d=e=>{let t=null;switch(e.key){case"Enter":u(e);break;case"ArrowRight":{const n=l.indexOf(e.currentTarget)+1;t=l[n]??l[0];break}case"ArrowLeft":{const n=l.indexOf(e.currentTarget)-1;t=l[n]??l[l.length-1];break}}t?.focus()};return(0,g.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.A)("tabs",{"tabs--block":n},t),children:o.map((e=>{let{value:t,label:n,attributes:i}=e;return(0,g.jsx)("li",{role:"tab",tabIndex:a===t?0:-1,"aria-selected":a===t,ref:e=>l.push(e),onKeyDown:d,onClick:u,...i,className:(0,r.A)("tabs__item",b.tabItem,i?.className,{"tabs__item--active":a===t}),children:n??t},t)}))})}function y(e){let{lazy:t,children:n,selectedValue:r}=e;const i=(Array.isArray(n)?n:[n]).filter(Boolean);if(t){const e=i.find((e=>e.props.value===r));return e?(0,a.cloneElement)(e,{className:"margin-top--md"}):null}return(0,g.jsx)("div",{className:"margin-top--md",children:i.map(((e,t)=>(0,a.cloneElement)(e,{key:t,hidden:e.props.value!==r})))})}function w(e){const t=m(e);return(0,g.jsxs)("div",{className:(0,r.A)("tabs-container",b.tabList),children:[(0,g.jsx)(k,{...t,...e}),(0,g.jsx)(y,{...t,...e})]})}function x(e){const t=(0,v.A)();return(0,g.jsx)(w,{...e,children:d(e.children)},String(t))}},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>o});var a=n(6540);const r={},i=a.createContext(r);function s(e){const t=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),a.createElement(i.Provider,{value:t},e.children)}}}]);