"use strict";(self.webpackChunkkira_documentation=self.webpackChunkkira_documentation||[]).push([[4935],{4252:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>r,toc:()=>c});var s=n(5893),a=n(1151);n(4866),n(5162);const i={title:"Concept",sidebar_position:0,slug:"concept"},o=void 0,r={id:"backend---sekai/modules/slashing/concept",title:"Concept",description:"Slashing is a commonly used technique in permissionless Proof-of-Stake networks to handle Sybil vulnerabilities and ensure operator incentives align with the network's goals (for more details, see the Consensus page). However, the combination of a weighted voting mechanism and firm slashing provisions doesn't necessarily ensure that participant intentions align with the network's long-term interests. The issue arises from the the fundamental limitations of permissionless systems that rely on participant rationality, which isn't always secure. More specifically, security models based on rationality may prove insufficient in open, \u2018permissionless\u2019 systems as they fail to consider the possibility of rational actors exploiting the system for external benefits, leaving the system vulnerable to a wider array of attacks beyond the scope of the rationality framework. As we transition towards a multi-chain \"Internet of Blockchains\" paradigm, this concern intensifies. Furthermore, slashing mechanisms can exacerbate the risk for smaller, home-based node operators who may fear severe financial repercussions for honest errors or system failures, while simultaneously amplifying risk for delegators. This double-edged effect fosters a centralizing trend, pushing node operators towards more centralized, and arguably more secure, cloud services like AWS, while also encouraging delegators to opt for these seemingly safer nodes for the protection of their assets. Such shifts unintentionally undermine the decentralization principles at the core of blockchain networks, leading to an unproductive dynamic within the ecosystem.",source:"@site/tabs/docs/backend---sekai/modules/slashing/concept.mdx",sourceDirName:"backend---sekai/modules/slashing",slug:"/backend---sekai/modules/slashing/concept",permalink:"/docs/backend---sekai/modules/slashing/concept",draft:!1,unlisted:!1,editUrl:"https://github.com/KiraCore/docs.kira.network/issues/new?assignees=&labels=documentation,issue&projects=&template=report_an_issue.yaml&title=%5BISSUE+REPORT%5D&page-github=/docs/backend---sekai/modules/slashing/concept&page-local=backend---sekai/modules/slashing/concept.mdx",tags:[],version:"current",lastUpdatedAt:1716175504e3,sidebarPosition:0,frontMatter:{title:"Concept",sidebar_position:0,slug:"concept"},sidebar:"defaultSidebar",previous:{title:"Delegators",permalink:"/docs/backend---sekai/modules/multistaking/delegators"},next:{title:"Jailing & Slashing Procedures",permalink:"/docs/backend---sekai/modules/slashing/jailing--slashing-procedures"}},l={},c=[{value:"Governance-driven Slashing",id:"7e972def4a3c4b5b9cd097f2664ee037",level:2},{value:"Uptime Ranking System",id:"b8e58ce09d134309a60fb2030912fbed",level:2}];function u(e){const t={a:"a",h2:"h2",p:"p",...(0,a.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.p,{children:["Slashing is a commonly used technique in permissionless Proof-of-Stake networks to handle Sybil vulnerabilities and ensure operator incentives align with the network's goals (for more details, see the ",(0,s.jsx)(t.a,{href:"https://claude.ai/chat/link-to-consensus-page",children:"Consensus"})," page). However, the combination of a weighted voting mechanism and firm slashing provisions doesn't necessarily ensure that participant intentions align with the network's long-term interests. The issue arises from the ",(0,s.jsx)(t.a,{href:"https://bford.info/2019/09/23/rational/",children:"the fundamental limitations of permissionless systems"}),' that rely on participant rationality, which isn\'t always secure. More specifically, security models based on rationality may prove insufficient in open, \u2018permissionless\u2019 systems as they fail to consider the possibility of rational actors exploiting the system for external benefits, leaving the system vulnerable to a wider array of attacks beyond the scope of the rationality framework. As we transition towards a multi-chain "Internet of Blockchains" paradigm, this concern intensifies. Furthermore, slashing mechanisms can exacerbate the risk for smaller, home-based node operators who may fear severe financial repercussions for honest errors or system failures, while simultaneously amplifying risk for delegators. This double-edged effect fosters a centralizing trend, pushing node operators towards more centralized, and arguably more secure, cloud services like AWS, while also encouraging delegators to opt for these seemingly safer nodes for the protection of their assets. Such shifts unintentionally undermine the decentralization principles at the core of blockchain networks, leading to an unproductive dynamic within the ecosystem.']}),"\n",(0,s.jsx)(t.h2,{id:"7e972def4a3c4b5b9cd097f2664ee037",children:"Governance-driven Slashing"}),"\n",(0,s.jsx)(t.p,{children:"KIRA takes a unique stance on slashing. In KIRA's governance-permissioned validator set, the discretionary power of \u2018identified\u2019 governance members to remove malicious nodes enables the detection and mitigation of irrational, malicious behavior that might elude purely economic models. This allows for a more targeted approach to slashing, where only instances of double-signing are subject to potential penalties. These penalties are triggered automatically only when a certain number of validators are caught double-signing within a short time frame, serving as a deterrent against coordinated attacks. In all other cases, slashing is subject to governance approval. This approach minimizes the risk of severe consequences for minor or unintentional errors, reducing the fear of harsh penalties and encouraging a more diverse set of individuals to run validator nodes, including those operating from home environments. Furthermore, it alleviates the pressure on Delegators to prioritize security over decentralization when choosing nodes to stake with, as the network itself is designed to be resilient to a wider range of failures. The combination of automatic slashing under specific conditions, governance-supported slashing for individual cases, and the absence of downtime slashing makes it extremely unlikely for Consensus nodes and Delegators to face unwarranted penalties. This approach aligns more closely with Byzantine principles, as it takes into account the inevitability of human error and system failures, thus promoting a strong, diverse validator community and a more decentralized network overall."}),"\n",(0,s.jsx)(t.h2,{id:"b8e58ce09d134309a60fb2030912fbed",children:"Uptime Ranking System"}),"\n",(0,s.jsxs)(t.p,{children:["KIRA encourages consensus nodes uptime by implementing a ranking system that fosters a dynamic and competitive environment to collectively promote network reliability and high participation levels. KIRA builds upon the ",(0,s.jsx)(t.a,{href:"https://tendermint.com/",children:"Tendermint"})," consensus protocol, which ensures liveness by requiring a minimum of 2/3 + 1 of the consensus node set's total voting power to sign a block. While KIRA doesn't employ weighted voting and considers each node as having a single vote (per capita), the principle remains that it is not guaranteed for every node to sign every block as up to 1/3 of nodes can miss a block at any given time. This can be due to various factors, such as the random distribution of nodes around the world, limited networking connectivity between them, and the limited time that nodes have to wait for consensus votes. Accordingly, KIRA\u2019s ranking system is designed to adapt to these variables. The system's parameters are fine-tuned by KIRA network governance to align individual node performance with the broader network health. This approach ensures high levels of participation while upholding the robustness of the network."]})]})}function d(e={}){const{wrapper:t}={...(0,a.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},5162:(e,t,n)=>{n.d(t,{Z:()=>o});n(7294);var s=n(6905);const a={tabItem:"tabItem_Ymn6"};var i=n(5893);function o(e){let{children:t,hidden:n,className:o}=e;return(0,i.jsx)("div",{role:"tabpanel",className:(0,s.Z)(a.tabItem,o),hidden:n,children:t})}},4866:(e,t,n)=>{n.d(t,{Z:()=>x});var s=n(7294),a=n(6905),i=n(2466),o=n(6550),r=n(469),l=n(1980),c=n(7392),u=n(812);function d(e){return s.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,s.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function h(e){const{values:t,children:n}=e;return(0,s.useMemo)((()=>{const e=t??function(e){return d(e).map((e=>{let{props:{value:t,label:n,attributes:s,default:a}}=e;return{value:t,label:n,attributes:s,default:a}}))}(n);return function(e){const t=(0,c.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function m(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function p(e){let{queryString:t=!1,groupId:n}=e;const a=(0,o.k6)(),i=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,l._X)(i),(0,s.useCallback)((e=>{if(!i)return;const t=new URLSearchParams(a.location.search);t.set(i,e),a.replace({...a.location,search:t.toString()})}),[i,a])]}function f(e){const{defaultValue:t,queryString:n=!1,groupId:a}=e,i=h(e),[o,l]=(0,s.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!m({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const s=n.find((e=>e.default))??n[0];if(!s)throw new Error("Unexpected error: 0 tabValues");return s.value}({defaultValue:t,tabValues:i}))),[c,d]=p({queryString:n,groupId:a}),[f,g]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[a,i]=(0,u.Nk)(n);return[a,(0,s.useCallback)((e=>{n&&i.set(e)}),[n,i])]}({groupId:a}),b=(()=>{const e=c??f;return m({value:e,tabValues:i})?e:null})();(0,r.Z)((()=>{b&&l(b)}),[b]);return{selectedValue:o,selectValue:(0,s.useCallback)((e=>{if(!m({value:e,tabValues:i}))throw new Error(`Can't select invalid tab value=${e}`);l(e),d(e),g(e)}),[d,g,i]),tabValues:i}}var g=n(2389);const b={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var v=n(5893);function y(e){let{className:t,block:n,selectedValue:s,selectValue:o,tabValues:r}=e;const l=[],{blockElementScrollPositionUntilNextRender:c}=(0,i.o5)(),u=e=>{const t=e.currentTarget,n=l.indexOf(t),a=r[n].value;a!==s&&(c(t),o(a))},d=e=>{let t=null;switch(e.key){case"Enter":u(e);break;case"ArrowRight":{const n=l.indexOf(e.currentTarget)+1;t=l[n]??l[0];break}case"ArrowLeft":{const n=l.indexOf(e.currentTarget)-1;t=l[n]??l[l.length-1];break}}t?.focus()};return(0,v.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,a.Z)("tabs",{"tabs--block":n},t),children:r.map((e=>{let{value:t,label:n,attributes:i}=e;return(0,v.jsx)("li",{role:"tab",tabIndex:s===t?0:-1,"aria-selected":s===t,ref:e=>l.push(e),onKeyDown:d,onClick:u,...i,className:(0,a.Z)("tabs__item",b.tabItem,i?.className,{"tabs__item--active":s===t}),children:n??t},t)}))})}function k(e){let{lazy:t,children:n,selectedValue:a}=e;const i=(Array.isArray(n)?n:[n]).filter(Boolean);if(t){const e=i.find((e=>e.props.value===a));return e?(0,s.cloneElement)(e,{className:"margin-top--md"}):null}return(0,v.jsx)("div",{className:"margin-top--md",children:i.map(((e,t)=>(0,s.cloneElement)(e,{key:t,hidden:e.props.value!==a})))})}function w(e){const t=f(e);return(0,v.jsxs)("div",{className:(0,a.Z)("tabs-container",b.tabList),children:[(0,v.jsx)(y,{...t,...e}),(0,v.jsx)(k,{...t,...e})]})}function x(e){const t=(0,g.Z)();return(0,v.jsx)(w,{...e,children:d(e.children)},String(t))}},1151:(e,t,n)=>{n.d(t,{Z:()=>r,a:()=>o});var s=n(7294);const a={},i=s.createContext(a);function o(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);