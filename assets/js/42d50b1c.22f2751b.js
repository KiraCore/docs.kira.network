"use strict";(self.webpackChunkkira_documentation=self.webpackChunkkira_documentation||[]).push([[3606],{3308:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"bridge---torii/architecture","title":"Architecture","description":"Overview","source":"@site/tabs/docs/bridge---torii/architecture.mdx","sourceDirName":"bridge---torii","slug":"/bridge---torii/architecture","permalink":"/docs/bridge---torii/architecture","draft":false,"unlisted":false,"editUrl":"https://github.com/KiraCore/docs.kira.network/issues/new?assignees=&labels=documentation,issue&projects=&template=report_an_issue.yaml&title=%5BISSUE+REPORT%5D&page-github=/docs/bridge---torii/architecture&page-local=bridge---torii/architecture.mdx","tags":[],"version":"current","lastUpdatedAt":1742267078000,"sidebarPosition":1,"frontMatter":{"title":"Architecture","sidebar_position":1,"slug":"architecture"},"sidebar":"defaultSidebar","previous":{"title":"Overview","permalink":"/docs/bridge---torii/overview"},"next":{"title":"Deployment","permalink":"/docs/bridge---torii/deployment"}}');var s=t(4848),i=t(8453);t(5537),t(9329);const a={title:"Architecture",sidebar_position:1,slug:"architecture"},o=void 0,c={},l=[{value:"Overview",id:"1b9467da57b7812f86c1d06fbe67c6d3",level:2},{value:"Workflow",id:"1b9467da57b781b9aa88cd1aef385f6d",level:4},{value:"Torii Components",id:"1b9467da57b781a3a150cf792dfb387f",level:2},{value:"Sekai Bridge Nodes",id:"1b9467da57b781e983d0e0a8559bae62",level:3}];function d(e){const n={code:"code",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"1b9467da57b7812f86c1d06fbe67c6d3",children:"Overview"}),"\n",(0,s.jsx)(n.p,{children:"Torii consists of multiple services, each exposing specific ports for API communication, inter-node coordination, and transaction processing."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{src:t(8803).A+"",width:"2069",height:"1783"})}),"\n",(0,s.jsx)(n.h4,{id:"1b9467da57b781b9aa88cd1aef385f6d",children:"Workflow"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Initiation"})," \u2013 A request is sent to Sekai to transfer assets between Cosmos and Ethereum. CosmosIndexer or EthereumIndexer detects the transaction and forwards it to the bridge."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Signing"})," \u2013 SekaiBridgeTssApp nodes sign the transaction using TSS. The signature is verified before execution."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Execution"})," \u2013 The signed transaction is submitted to the respective blockchain."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Finalization"})," \u2013 The system indexes the transaction and updates storage."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"1b9467da57b781a3a150cf792dfb387f",children:"Torii Components"}),"\n",(0,s.jsx)(n.h3,{id:"1b9467da57b781e983d0e0a8559bae62",children:"Sekai Bridge Nodes"}),"\n",(0,s.jsx)(n.p,{children:"The Sekai Bridge Node is the core component enabling secure multi-party signing for cross-chain transfers. It leverages the tss-lib library to ivmplement a Multi-Party Threshold Signature Scheme (TSS) for both ECDSA and EdDSA, following the principles of Gennaro and Goldfeder 2020. This design ensures that no single entity controls the entire key."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Sekai Bridge Nodes configuration and API reference"}),"[broken link]"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Ports"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"8082"})," \u2013 Primary HTTP API endpoint."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"8889, 8890"})," \u2013 Internal communication channels for signing and coordination."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Ethereum Services"})}),"\n",(0,s.jsx)(n.p,{children:"These services handle all interactions with the Ethereum blockchain, covering both transaction creation and event monitoring."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"saiETHInteraction"})}),"\n",(0,s.jsxs)(n.p,{children:["Acts as an HTTP proxy for creating and managing transactions to Ethereum smart contracts. It enables users and other services to interact with bridge contracts by invoking methods, as well as dynamically add or remove bridge contracts from its monitoring list. Configured via a central ",(0,s.jsx)(n.code,{children:"config.yml"}),", this service streamlines the process of submitting Ethereum transactions through a simple, high-level API."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Ports"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"8882"})," \u2013 HTTP API for submitting Ethereum transactions."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"saiEthIndexer"})}),"\n",(0,s.jsxs)(n.p,{children:["Monitors the Ethereum blockchain for transactions involving specified contract addresses. It continuously scans blocks using a geth node, extracts relevant event data from matching transactions, and stores these details in a persistent storage layer. Additionally, it sends notifications to connected services when significant events occur. Its behavior is driven by parameters defined in a ",(0,s.jsx)(n.code,{children:"config.json"}),", including settings for the Ethereum node, storage service, and notification mechanism."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Ports"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"8881"})," \u2013 HTTP API for Ethereum event indexing."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Cosmos Services"})}),"\n",(0,s.jsx)(n.p,{children:"These services facilitate interactions with Cosmos SDK-based blockchains, providing streamlined transaction creation and real-time transaction monitoring."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"saiCosmosInteraction"})}),"\n",(0,s.jsx)(n.p,{children:"This service offers an HTTP API to create and submit transactions to Cosmos blockchains. It processes transaction requests by signing transactions with locally stored private keys and then sending them to the specified node. This setup simplifies the transaction process, allowing users and services to interact with Cosmos chains with ease."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Ports"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"8884"})," \u2013 HTTP API for executing Cosmos transactions."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"saiCosmosIndexer"})}),"\n",(0,s.jsx)(n.p,{children:"Designed to monitor the Cosmos blockchain for transactions linked to specific addresses, this service continuously scans for new transactions starting from a defined block height. It filters and indexes these transactions for later retrieval and auditing. Additionally, it provides HTTP handlers to add or remove addresses dynamically, ensuring flexible and up-to-date transaction tracking."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Ports"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"8883"})," \u2013 HTTP API for indexing Cosmos events."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Storage Service (Explorer)"})}),"\n",(0,s.jsx)(n.p,{children:"This service uses MongoDB to store and manage data from the bridge components. It collects records such as transaction logs, event notifications, and other related metadata. The service offers a RESTful API for creating, reading, updating/upserting, and deleting documents, which helps in tracking and analyzing the bridge's operational history."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Ports"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"8880"})," \u2013 Primary HTTP API endpoint."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"8881"})," \u2013 WebSocket connection."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"8882"})," \u2013 Socket connection."]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},5537:(e,n,t)=>{t.d(n,{A:()=>T});var r=t(6540),s=t(8215),i=t(5627),a=t(6347),o=t(372),c=t(604),l=t(1861),d=t(8749);function u(e){return r.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function h(e){const{values:n,children:t}=e;return(0,r.useMemo)((()=>{const e=n??function(e){return u(e).map((e=>{let{props:{value:n,label:t,attributes:r,default:s}}=e;return{value:n,label:t,attributes:r,default:s}}))}(t);return function(e){const n=(0,l.XI)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function g(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function f(e){let{queryString:n=!1,groupId:t}=e;const s=(0,a.W6)(),i=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:n,groupId:t});return[(0,c.aZ)(i),(0,r.useCallback)((e=>{if(!i)return;const n=new URLSearchParams(s.location.search);n.set(i,e),s.replace({...s.location,search:n.toString()})}),[i,s])]}function p(e){const{defaultValue:n,queryString:t=!1,groupId:s}=e,i=h(e),[a,c]=(0,r.useState)((()=>function(e){let{defaultValue:n,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!g({value:n,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const r=t.find((e=>e.default))??t[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:n,tabValues:i}))),[l,u]=f({queryString:t,groupId:s}),[p,m]=function(e){let{groupId:n}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(n),[s,i]=(0,d.Dv)(t);return[s,(0,r.useCallback)((e=>{t&&i.set(e)}),[t,i])]}({groupId:s}),b=(()=>{const e=l??p;return g({value:e,tabValues:i})?e:null})();(0,o.A)((()=>{b&&c(b)}),[b]);return{selectedValue:a,selectValue:(0,r.useCallback)((e=>{if(!g({value:e,tabValues:i}))throw new Error(`Can't select invalid tab value=${e}`);c(e),u(e),m(e)}),[u,m,i]),tabValues:i}}var m=t(9136);const b={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var x=t(4848);function v(e){let{className:n,block:t,selectedValue:r,selectValue:a,tabValues:o}=e;const c=[],{blockElementScrollPositionUntilNextRender:l}=(0,i.a_)(),d=e=>{const n=e.currentTarget,t=c.indexOf(n),s=o[t].value;s!==r&&(l(n),a(s))},u=e=>{let n=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const t=c.indexOf(e.currentTarget)+1;n=c[t]??c[0];break}case"ArrowLeft":{const t=c.indexOf(e.currentTarget)-1;n=c[t]??c[c.length-1];break}}n?.focus()};return(0,x.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.A)("tabs",{"tabs--block":t},n),children:o.map((e=>{let{value:n,label:t,attributes:i}=e;return(0,x.jsx)("li",{role:"tab",tabIndex:r===n?0:-1,"aria-selected":r===n,ref:e=>{c.push(e)},onKeyDown:u,onClick:d,...i,className:(0,s.A)("tabs__item",b.tabItem,i?.className,{"tabs__item--active":r===n}),children:t??n},n)}))})}function j(e){let{lazy:n,children:t,selectedValue:i}=e;const a=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=a.find((e=>e.props.value===i));return e?(0,r.cloneElement)(e,{className:(0,s.A)("margin-top--md",e.props.className)}):null}return(0,x.jsx)("div",{className:"margin-top--md",children:a.map(((e,n)=>(0,r.cloneElement)(e,{key:n,hidden:e.props.value!==i})))})}function y(e){const n=p(e);return(0,x.jsxs)("div",{className:(0,s.A)("tabs-container",b.tabList),children:[(0,x.jsx)(v,{...n,...e}),(0,x.jsx)(j,{...n,...e})]})}function T(e){const n=(0,m.A)();return(0,x.jsx)(y,{...e,children:u(e.children)},String(n))}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var r=t(6540);const s={},i=r.createContext(s);function a(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(i.Provider,{value:n},e.children)}},8803:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/1239739514-09d8aa727c16d9420425bfab9fffce40.png"},9329:(e,n,t)=>{t.d(n,{A:()=>a});t(6540);var r=t(8215);const s={tabItem:"tabItem_Ymn6"};var i=t(4848);function a(e){let{children:n,hidden:t,className:a}=e;return(0,i.jsx)("div",{role:"tabpanel",className:(0,r.A)(s.tabItem,a),hidden:t,children:n})}}}]);