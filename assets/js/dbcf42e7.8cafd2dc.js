"use strict";(self.webpackChunkkira_documentation=self.webpackChunkkira_documentation||[]).push([[5931],{3621:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>c});var n=i(5893),a=i(1151);i(4866),i(5162);const s={title:"Overview",sidebar_position:0,slug:"/583bcfe4-077c-4987-8a8b-e20bdc507b43"},o=void 0,r={id:"backend---sekai/modules-&-cli/modules/layer-2/overview",title:"Overview",description:"KIRA's Layer 2, termed Pessimistic Rolldowns, optimizes computational efficiency and transaction bundling. Our unique Virtual Finality Gadget expedites the verification of computation results, fostering a versatile platform that caters to both 'code is law' and judgment-based applications. This is more than a platform\u2014it's a launchpad for developers to define their own rules and easily iterate on diverse applications.",source:"@site/tabs/Docs/backend---sekai/modules-&-cli/modules/layer-2/overview.mdx",sourceDirName:"backend---sekai/modules-&-cli/modules/layer-2",slug:"/583bcfe4-077c-4987-8a8b-e20bdc507b43",permalink:"/docs/583bcfe4-077c-4987-8a8b-e20bdc507b43",draft:!1,unlisted:!1,editUrl:"https://github.com/KiraCore/docs.kira.network/issues/new?assignees=&labels=documentation,issue&projects=&template=report_an_issue.yaml&title=%5BISSUE+REPORT%5D&page-github=/docs/583bcfe4-077c-4987-8a8b-e20bdc507b43&page-local=backend---sekai/modules-&-cli/modules/layer-2/overview.mdx",tags:[],version:"current",sidebarPosition:0,frontMatter:{title:"Overview",sidebar_position:0,slug:"/583bcfe4-077c-4987-8a8b-e20bdc507b43"},sidebar:"defaultSidebar",previous:{title:"Poor Network Conditions",permalink:"/docs/65e3e6fe-040a-4716-b13b-9e27def6ff9d"},next:{title:"Overview",permalink:"/docs/853ef97c-8fb2-42e7-8c35-eee173e103f3"}},l={},c=[{value:"Architecture",id:"d9cd842ec8294d6aa8153fc558ebfa2e",level:4},{value:"Virtual Finality Gadget",id:"ba2d35e3552244488d5aba94767a1b96",level:3},{value:"Non-deterministic Code",id:"9ca9c3e8b9a3403ea5161b404484b7ba",level:4},{value:"Sessions",id:"0a92a379be114fa7b5a91bc4a1c699b0",level:4},{value:"Multi-party Computation",id:"4bc51322d5994539b60a004f23ddd0c7",level:4},{value:"Replication",id:"9f96ce9b732249e0a77b1fcb0f5c2d86",level:4},{value:"Ilo / Incentives",id:"eb3f3ea623d34d0da14b60e8f6c6c5ea",level:4},{value:"KIRA Layer 2: Pessimistic Rolldowns Overview",id:"6cb24db5a1144a2d9c0fcb4ba819eb2d",level:2},{value:"Rollapp Architecture",id:"78cd352955c044d3a813e1c8298b0284",level:3},{value:"Pessimistic Assumption and Verification",id:"2b94d06861bb4fdcae2f3e8e22772051",level:3},{value:"Continuous Computation and State Replication",id:"938610ac812847a5bc60ba50ea97dae2",level:3},{value:"Economic Security Via Roles and Incentives",id:"f4ac16aa68e64a5db2e15a27653a57c8",level:3},{value:"Enabling Features",id:"4fdd27bada1342509f1976c7e4ccef66",level:3}];function d(e){const t={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",hr:"hr",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,a.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.p,{children:"KIRA's Layer 2, termed Pessimistic Rolldowns, optimizes computational efficiency and transaction bundling. Our unique Virtual Finality Gadget expedites the verification of computation results, fostering a versatile platform that caters to both 'code is law' and judgment-based applications. This is more than a platform\u2014it's a launchpad for developers to define their own rules and easily iterate on diverse applications."}),"\n",(0,n.jsx)(t.h4,{id:"d9cd842ec8294d6aa8153fc558ebfa2e",children:"Architecture"}),"\n",(0,n.jsx)(t.p,{children:"KIRA\u2019s main thesis regarding decentralized applications is that the base layer (backend a.k.a blockchain) of any application should only contain the most basic state machine code essential to securing the network, coordinating governance, and persisting users' balances. Any execution of an arbitrary code MUST take place on the dedicated execution layer independent from the core blockchain application (off-chain). In short, the base layer (on-chain) should be responsible for settlement, and the execution layer (off-chain) for computation / arbitrary code execution."}),"\n",(0,n.jsx)(t.p,{children:"The current stack of the network consists of the static page frontend application (MIRO), middleware (INTERX) that acts like a decentralized API, and a backend application in the form of a blockchain (SEKAI). In the L2 implementation, we will have to focus on both SEKAI and INTERX to achieve scaling since the blockchain application (SEKAI) alone can\u2019t execute anything that is not part of a state machine code. Let\u2019s have a look at the high-level roles that each part of the infrastructure will have:"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{src:i(444).Z+"",width:"937",height:"644"})}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.strong,{children:"SEKAI"})}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Allow anyone (users) to submit executable code (deterministic code) as SHA256 hash and URL/CID to its source"}),"\n",(0,n.jsx)(t.li,{children:"Allow validators to submit their candidacy to run the executable (dApp)"}),"\n",(0,n.jsx)(t.li,{children:"Allow validators to register in IR[broken link] their INTERX nodes that will be executing particular dApps"}),"\n",(0,n.jsx)(t.li,{children:"Allow users to deposit and withdraw tokens to/from the dApp (lock/unlock assets)"}),"\n",(0,n.jsx)(t.li,{children:"Allow the validator who runs the dApp session to propose a token balance change and the latest dApp state as SHA256 hash"}),"\n",(0,n.jsx)(t.li,{children:"Allow other validators who participate in state verification to accept/reject dApp state hash and changes to account balances"}),"\n",(0,n.jsx)(t.li,{children:"Allow anyone (users) to register a fisherman node (interx), that will be verifying the correctness of the dApp execution"}),"\n",(0,n.jsx)(t.li,{children:"If the dApp state hash is challenged (rejected) then halt the dApp and allow validators to vote on un-halting the dApp or accepting/rejecting the state hash"}),"\n",(0,n.jsx)(t.li,{children:"Allow dApps to mint & burn tokens (essential for bridges) as well as publish key-value pair data on-chain to enable compossibility between dApps"}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.strong,{children:"INTERX"})}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Determine if the INTERX node belongs to the validator and should participate in assisting execution"}),"\n",(0,n.jsx)(t.li,{children:"Download the application docker image and verify SHA256"}),"\n",(0,n.jsx)(t.li,{children:"Expose application images on demand to application launcher"}),"\n",(0,n.jsx)(t.li,{children:"Allow the application container to communicate with INTERX API (be able to observe blockchain state and state of other apps)"}),"\n",(0,n.jsx)(t.li,{children:"Provide persistent storage for the application state and user input"}),"\n",(0,n.jsx)(t.li,{children:"Provide proxy service for the application container on the dedicated port range"}),"\n",(0,n.jsx)(t.li,{children:"Publish the application state to sekai or accept/reject state in the verification/fisherman mode"}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.strong,{children:"KM"})}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"deploy application image sourced from INTERX"}),"\n",(0,n.jsx)(t.li,{children:"deploy app verification image sourced from INTERX"}),"\n",(0,n.jsx)(t.li,{children:"expose dedicated ports range to INTERX"}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.strong,{children:"FRONTEND"})}),"\n",(0,n.jsx)(t.p,{children:"For each application, the frontend should be a static page (e.g. hosted on IPFS) that will communicate with selected INTERX nodes exposing the API interface. This application has to be developed independently for each app."}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"discover session leader IP through data stored on L1"}),"\n",(0,n.jsx)(t.li,{children:"interact with a docker container through the INTERX proxy"}),"\n"]}),"\n",(0,n.jsx)(t.h3,{id:"ba2d35e3552244488d5aba94767a1b96",children:"Virtual Finality Gadget"}),"\n",(0,n.jsxs)(t.p,{children:["In our implementation of Layer 2 (responsible for arbitrary code execution), we will utilize a mechanism similar to ",(0,n.jsx)(t.a,{href:"https://ethereum.org/en/developers/docs/scaling/optimistic-rollups/",children:"ethereum optimistic rollups"})," where transactions and final results of the computation are bundled and settled on the base layer. In the case of optimistic rollups on ethereum, the final state of execution (bundle) is \u201coptimistically\u201d assumed to be correct and can be challenged within a \u201cchallenge period\u201d. In our case, we will be \u201cpessimistically\u201d assuming the final result of the computation to be NOT correct and only settle it if either a sufficient number of verifications was performed within the \u201cchallenge period\u201d or if any node who was \u201cobserving\u201d the computation arrived to different results and wants to stop the settlement from happening until 2/3+ of validators verify the correctness. We will call our mechanism ",(0,n.jsx)(t.strong,{children:"pessimistic rolldowns"})," since we do not assume correctness and we will be rolling the state of computation down into our settlement layer in a bundled form."]}),"\n",(0,n.jsxs)(t.p,{children:["Since our time-invariant deterministic computational black box can be executing possibly ANY code within limitations defined before, we must provide a way for the fisherman to efficiently verify the correctness of the results. Since the problem we are trying to solve is generalized computing it is realistic to assume that there will never be a single perfect way to speed up the verification of the computation and in some cases, verification might not even adhere to the logic that can be put in the code! An example here is gaming where the judgment of a human or AI might take priority over exploitable game rules. Whenever the \u201ccode is law\u201d principle is insufficient or not realistic to be adhered to in order to provide the expected user experience we need to provide a fast and efficient way for verification. The virtual finality gadget is a simplified deterministic machine resembling our \u201cdApp black box\u201d that, given the input ",(0,n.jsx)(t.code,{children:"s(t-1)"}),", and output ",(0,n.jsx)(t.code,{children:"s(t)"})," produces a simple \u201cyes\u201d or \u201cno\u201d answer to whether the output ",(0,n.jsx)(t.code,{children:"s(t)"})," was computed correctly. The verification process can be simply re-running the application code with an input of ",(0,n.jsx)(t.code,{children:"s(t-1)"})," or employing much more clever techniques, such as probabilistic checks of the transaction included in the Merkle-root bundling checkpoint used in rollups. KIRA L2 is simply a protocol and NOT an \u201cout of the box\u201d solution for every possible problem, the default verification means are a dumb recomputation, meanwhile, the developer gains the ability to define his own \u201cmy code is law\u201d rules."]}),"\n",(0,n.jsx)(t.h4,{id:"9ca9c3e8b9a3403ea5161b404484b7ba",children:"Non-deterministic Code"}),"\n",(0,n.jsxs)(t.p,{children:["Whenever referring to \u201carbitrary code\u201d execution we have to make clear what type of code and programming languages we can support. In the case of our pessimistic rolldowns, we will treat \u201ccode\u201d as a black box behaving as follows ",(0,n.jsx)(t.code,{children:"blackBoxFunc(s(t-1),x) => s(t)"})," where ",(0,n.jsx)(t.code,{children:"s(t-1)"})," is a previous state of execution at time ",(0,n.jsx)(t.code,{children:"t-1"})," and where ",(0,n.jsx)(t.code,{children:"x"})," is a list of user inputs such that the new state ",(0,n.jsx)(t.code,{children:"s(t)"})," will always be the same given the same inputs to our ",(0,n.jsx)(t.code,{children:"blackBoxFunc"}),". In simple terms, we can say that the code within our \u201cblack box\u201d must be ",(0,n.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Deterministic_system#:~:text=In%20mathematics%2C%20computer%20science%20and,starting%20condition%20or%20initial%20state.",children:"deterministic"}),", and \u201cwhenever the same input enters the black box, its corresponding output must be exactly the same value or blob of data every single time\u201d. As long as this single rule is preserved and our output is predictable and ordered the code can be written in any programming language and the results of computation can be verified regardless of time, or any other external conditions."]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{src:i(1559).Z+"",width:"885",height:"768"})}),"\n",(0,n.jsxs)(t.p,{children:["Suppose given the previous state of execution, input from the settlement layer, and an ordered list of user input anyone can recompute the new state and output that should be settled on the base layer. In that case, execution of any deterministic code is possible with security guarantees equal to those of the base layer. Any party with a vested interest in the correct execution of the code can operate a dedicated \u201c",(0,n.jsx)(t.strong,{children:"fisherman"}),"\u201d / verifier node that can observe the execution of the deterministic code and report on-chain any doubts in regard to the final results."]}),"\n",(0,n.jsx)(t.h4,{id:"0a92a379be114fa7b5a91bc4a1c699b0",children:"Sessions"}),"\n",(0,n.jsxs)(t.p,{children:["Since the L2 code that is executed must be at some point verified and changes to the blockchain state settled on L1, we need to define a point in time after which the execution must stop and the verification process begins. The period of time and the process during which the execution is occurring we will call \u201c",(0,n.jsx)(t.strong,{children:"dApp Session"}),"\u201d. Every dApp Session is going to be executed by only a single validator (dApp leader) while verification will be done by the remaining validators and fisherman (dApp verifiers). After dApp Session ends the dApp leader is going to submit on-chain a result of his computation (changes to the blockchain, e.g. changes in token balances) and a new hash of a dApp state (changes to its internal database, e.g. position of players in a video game or changes to account balances after swapping tokens). Proposed hashes and changes are then voted on by dApp executors who collect necessary input from the dApp leader to re-execute or otherwise verify computations using the Virtual Finality Gadget. As long as more than 2/3 of dApp Executors take part in voting and ALL of them agree on the session results including ALL dApp Verifiers, the changes will be accepted. While the approval of Executors is essential, the approval of Verifiers is optional, meaning that even if the majority of fisherman agrees with the new session changes they do not have the right to finalize the state transition. The only universal right of a fisherman is to halt the application if they arrive at the conclusion that the state transitions of the dApp are incorrect."]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.em,{children:"NOTE: The number of dApp Verifiers (fishermen) can be much greater than the number of dApp Executors (possible dApp Leaders). At any point in time, there will only be a single dApp leader."})}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{src:i(3539).Z+"",width:"780",height:"521"})}),"\n",(0,n.jsxs)(t.p,{children:["Since verification of the correct execution might take quite a while we will appoint a new leader after the first one finishes execution and allow him to continue dApp execution immediately, without having to wait for the verification process to be completed. The dApp leader must be an active (online) validator and will be chosen in a ",(0,n.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Round-robin_scheduling",children:"Round-robin"})," manner, that is simply as next in line by the iterative validator ID. The difference between Validators and Fishermen/Verifiers is that validators can be leaders while fishermen can never be leaders and propose changes to the blockchain."]}),"\n",(0,n.jsx)(t.h4,{id:"4bc51322d5994539b60a004f23ddd0c7",children:"Multi-party Computation"}),"\n",(0,n.jsxs)(t.p,{children:["It might happen that your dApp might require ",(0,n.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Secure_multi-party_computation",children:"Multi-Party Computation"})," (MPC) to operate, one example of that might be the MPC random number generation necessary in many types of games utilizing a simple ",(0,n.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Commitment_scheme",children:"Commitment Scheme"}),", another example can be a ",(0,n.jsx)(t.a,{href:"https://everipedia.org/wiki/lang_en/threshold-signature-scheme-tss",children:"Threshold Signature Scheme "}),"(TSS) useful in securing and creating pegged bridges between cryptocurrencies such as BTC or ETH. The obvious problem here is that it\u2019s not just one dApp Leader that will be tasked with computation but multiple validators must cooperate at the same time and perform certain types of parallel computations."]}),"\n",(0,n.jsxs)(t.p,{children:["To resolve the problem of the leader-verifiers having to cooperate in calculations we can treat the \u201cverifiers\u201d the exact same way we would treat \u201cusers\u201d - by awaiting their input to the dedicated INTERX endpoint",(0,n.jsx)(t.code,{children:"/dapp/<dapp-id>/txs"})," of the dApp leader, that is the exact same endpoint that users would forward their internal dApp txs\u2019 to. Whenever MPC is needed your dApp docker container can ",(0,n.jsx)(t.a,{href:"https://docs.docker.com/config/containers/multi-service_container/",children:"run multiple services"})," using a short init script. The init script can then parallelize the operation of the \u201cverification\u201d and communication/cooperation with a leader the same way the client application would at the same time."]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{src:i(1568).Z+"",width:"933",height:"528"})}),"\n",(0,n.jsx)(t.h4,{id:"9f96ce9b732249e0a77b1fcb0f5c2d86",children:"Replication"}),"\n",(0,n.jsxs)(t.p,{children:["Once execution of the Session ends the dApp Leader must be able to share the results of his computation which includes dApp database changes, on-chain changes (e.g changes in balances), and an ordered list of the user input so that anyone can verify the Session Results. If the Session Results were not shared in a timely manner then dApp Verifies will not be able to approve them and all changes will be completely discarded. There might be many reasons why the session results might be lost, this includes hardware faults, networking faults, software implementation faults, intentional or unintentional DOS/DDOS, and even natural disasters. To ensure the highest chances of success during the state replication process we will first have to make all data available to be downloaded from the dApp Leader INTERX node by utilizing our custom ",(0,n.jsx)(t.code,{children:"<interx-addr>:11000/download"})," endpoint. Next, we will have to define connection limits but at the same time ensure that downloading priority is guaranteed for all dApp Verifiers and in the case where dApp Leader becomes unavailable all verifies can try to fetch the data from each other (e.g. Leader is down, but one of the verifiers managed to download the state in time)."]}),"\n",(0,n.jsxs)(t.p,{children:["The main disadvantage of the session-based replication is that our dApp might become unresponsive until the next leader can fetch the final Session Results or perform a verification before continuing the execution. To mitigate that issue the next leader can entirely ignore the verification process completely and \u201con the go\u201d fetch the latest user inputs directly from the current leader. We can optimistically assume that the computation is correct and in the case where it is not we can simply discard both previous and the current session data (which should be a rare and unlikely scenario). A dedicated stream communication channel could be established between the current and next leader to on-the-go fetch all incoming data. If it happened that the current or the next leader suddenly becomes unresponsive before the new session starts then we can have any consecutive leader pick up the changes by fetching them from one of the available ",(0,n.jsx)(t.code,{children:"<interx-addr>:11000/download"})," endpoints (assuming new state was shared in time)."]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{src:i(3703).Z+"",width:"1200",height:"701"})}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.em,{children:"NOTE: It doesn\u2019t really matter who proposes changes to the blockchain and propagates hashes of the session result as long as the bundle of the user inputs was signed by the leader executing it. This means that the current dApp leader can go offline even before finalizing his session and in the case of failure offload responsibility to the next leader who was live-fetching all the user input stream data. In the MVP implementation, we will only focus on the simplest cases and discard any improvements that can be done at a later stage."})}),"\n",(0,n.jsx)(t.h4,{id:"eb3f3ea623d34d0da14b60e8f6c6c5ea",children:"Ilo / Incentives"}),"\n",(0,n.jsx)(t.p,{children:"Every dApp should have the ability to sustain its operations and long-term development. One of the simplest ways to achieve that is by allowing each dApp to issue its own tokens with the approval of the governance. Profits from the dApp operations (such as fees) can then be split between dApp Executors, dApp Verifiers & the dApp Token Holders. Token issuance module can at the same time be used to enable bridging of tokens from other networks without the need to use cross-chain protocols such as XCMP & IBC. However, those very XCM-protocols can be supported as \u201cplugins\u201d - meaning a dedicated dApp can be handling communication with Polkadot and another one with Cosmos, Ethereum, or other networks."}),"\n",(0,n.jsx)(t.p,{children:"To prevent spam each dApp should have a quota on the number of tokens it can issue and their max supply. By default, each dApp will have just one native (default) token. Once the default token is created by the dApp it will not be possible to remove or change its denomination or name. The purpose of the default token will be the rewards distributions and governance functions."}),"\n",(0,n.jsx)(t.hr,{}),"\n",(0,n.jsx)(t.hr,{}),"\n",(0,n.jsx)(t.h2,{id:"6cb24db5a1144a2d9c0fcb4ba819eb2d",children:"KIRA Layer 2: Pessimistic Rolldowns Overview"}),"\n",(0,n.jsx)(t.p,{children:"The core architectural principle of KIRA is the total separation of the execution and settlement. The base layer (SEKAI) handles critical functions like governance, token transfers, persistence of balances, staking, and all security-critical state machine logic. However, it does not execute arbitrary code for decentralized applications (it is not possible to deploy smart contracts on SEKAI). Instead, the execution of dApps takes place off-chain on dedicated execution layers. We refer to these off-chain applications as RollApps."}),"\n",(0,n.jsx)(t.p,{children:"This separation of execution and settlement is an increasingly adopted scaling approach, as increasing the throughput of a monolithic base layer beyond the constraints of the slowest nodes is fundamentally limited by physical networking factors. In a base layer blockchain requiring total ordering of transactions, data propagation delays present a significant bottleneck. As the amount of data to be shared increases, the time required to disseminate it to all nodes grows, limited by the transmission speeds between nodes. This propagation delay restricts the maximum throughput achievable, as the system must stay synchronized with even the slowest nodes required for making the consensus progress."}),"\n",(0,n.jsx)(t.p,{children:"An emerging solution is the concept of Data Availability Sampling (DAS), which advocates an architectural shift towards modularity. In DAS systems like Celestia, the base layer solely ensures data availability, while intensive computation occurs off-chain by separate executors. The premise is that by making data available, even lightweight verifying nodes can gain confidence in computation integrity without linearly scaling bandwidth. This allows pushing intensive workloads to more capable executors, avoiding prohibitive hardware demands on all verifiers."}),"\n",(0,n.jsx)(t.p,{children:"However, KIRA's thesis is that while dispersing data across nodes enables decentralized storage, it does not necessarily provide the highly available real-time access with unlimited bandwidth required for persistently storing state in high-value applications. Additionally, because DAS architectures lack economic integration between the data availability nodes and the off-chain execution environments, there is no aligned security model or notion of shared economic incentives across these separate system components."}),"\n",(0,n.jsx)(t.p,{children:"Beyond the fixed data replication factors which present limitations, as applications have diverse needs for availability, persistence, and access speeds, DAS's one-size-fits-all approach cannot optimally handle these varying requirements across different use cases. KIRA's design philosophy is that truly modular blockchain architecture requires flexibility to adjust the scalability-decentralization tradeoffs dynamically based on each application's specific trust assumptions and performance needs."}),"\n",(0,n.jsx)(t.p,{children:"This separation allows parallel scaling of computational resources, storage, and networking capabilities for each dApp, and avoid the pitfalls of executing everything on the base layer and/or by nodes that are unrelated to the application itself. Unlike optimistic rollup systems that assume computation correctness unless challenged, KIRA's Pessimistic Rolldowns operate under the assumption that all off-chain computations are potentially incorrect. Computation results from dApps must be verified through consensus among a permissionless set of Verifier nodes before being settled to the SEKAI base layer as the canonical state."}),"\n",(0,n.jsx)(t.p,{children:"By separating execution from settlement, scalability can be achieved by parallelizing the off-chain computations across many execution layers, while relying on the high-security decentralized consensus of the base layer for periodically settling state transitions."}),"\n",(0,n.jsx)(t.p,{children:"Many blockchain projects have embraced or pivoted towards similar rollup and Layer 2 scaling roadmaps to circumvent these fundamental limitations while preserving robust decentralization and security inherited from their base settlement layers."}),"\n",(0,n.jsx)(t.p,{children:"The core architectural principle of KIRA is the separation of the execution and settlement layers: The base layer (SEKAI) handles critical functions like governance, token transfers, staking, and all security-critical state machine logic but does not execute arbitrary code for decentralized applications (dApps). Instead, the execution of dApps takes place off-chain on dedicated execution layers. This scaling practice is widely adopted or part of part of roadmap of most chain have pivoted to a rollup-centric roadmap , this is because increasing the bandwidth of the system beyond the speed of the slowest node in the supermajority is impossible, that\u2019s basically CAP, it comes from impossibility of propagating message over a cable among soo many nodes, its a physical constraint, the more data you have the longer it takes to share with other nodes in the network, which is pretty obvious conclusion."}),"\n",(0,n.jsx)(t.h3,{id:"78cd352955c044d3a813e1c8298b0284",children:"Rollapp Architecture"}),"\n",(0,n.jsx)(t.p,{children:"A RollApp consists of two key components:"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Execution Container"}),": This defines the core application logic as deterministic code that can be written in any programming language. There is no requirement is that the code must be deterministic, producing the same output for a given set of inputs and previous state."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Verification Container"}),": This component specifies the rules and methods for efficiently verifying the correctness of the state transitions produced by the Execution Container's computations."]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:'Before a RollApp can be launched on KIRA, its code, resource requirements, and other metadata must be submitted on-chain by "Controllers" (similar to Ethereum contract deployers). A minimum bond of KEX tokens is required to prevent spam. If the bond target is crowdsourced, RollApp ownership tokens are minted and provided to liquidity providers.'}),"\n",(0,n.jsx)(t.h3,{id:"2b94d06861bb4fdcae2f3e8e22772051",children:"Pessimistic Assumption and Verification"}),"\n",(0,n.jsx)(t.p,{children:"In contrast to optimistic rollup systems which assume computations are valid unless challenged, KIRA's Pessimistic Rolldowns pessimistically assume that all RollApp computations are potentially incorrect. The results of each computation must be verified through a decentralized consensus process before being accepted and settled on the canonical SEKAI base layer."}),"\n",(0,n.jsx)(t.p,{children:"To enable this verification, RollApp execution is divided into discrete sessions. In each session:"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsx)(t.li,{children:"A single Executor node, selected from the active validator set, acts as the leader. It executes the RollApp code and proposes a new state root along with any changes to account balances on SEKAI."}),"\n",(0,n.jsx)(t.li,{children:'Other Executors, as well as permissionless external "Fishermen" nodes, re-execute the RollApp using the same data streams to validate the leader\'s results.'}),"\n",(0,n.jsx)(t.li,{children:"If at least 2/3 of the Verifiers (including all Executors) unanimously agree on the results, the state transition is finalized on SEKAI. Even a single dissenting Verifier can halt the transition."}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"This process runs in a pipelined manner - as soon as one leader finishes their session, the next leader can immediately begin executing the subsequent session, enabling continuous uninterrupted computation."}),"\n",(0,n.jsx)(t.p,{children:'To optimize verification, RollApps can define their own lightweight "Virtual Finality Gadgets" as alternatives to full re-execution for efficiently validating results.'}),"\n",(0,n.jsx)(t.h3,{id:"938610ac812847a5bc60ba50ea97dae2",children:"Continuous Computation and State Replication"}),"\n",(0,n.jsx)(t.p,{children:'One key advantages of the pessimistic session-based model is that it avoids the "halting problem" faced by monolithic smart contracts. By having multiple overlapping sessions, even if one session\'s results are rejected, the RollApp can continue executing with the next leader rather than fully halting.'}),"\n",(0,n.jsx)(t.p,{children:"To maintain liveness, RollApp state must be continuously replicated from the current leader to the next in line. This is achieved through direct peer-to-peer connections where the new leader can fetch the latest state on-the-fly as the prior leader is executing. Replicated state is authenticated by the leader's signature."}),"\n",(0,n.jsx)(t.p,{children:"In cases where the current or next leader goes offline, any following leader can fetch replicated state from the available pool of Verifiers who have already downloaded it, ensuring continuous operation."}),"\n",(0,n.jsx)(t.h3,{id:"f4ac16aa68e64a5db2e15a27653a57c8",children:"Economic Security Via Roles and Incentives"}),"\n",(0,n.jsx)(t.p,{children:"There are two primary roles involved in the RollApp verification process:"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Executors"}),": These are the existing KIRA validator nodes that optionally choose to run the RollApp Execution Container. One Executor is elected as the leader for each session and proposes state changes to SEKAI. Executors are held accountable by being subject to removal from their privilieged validator role and slashing of their staked income if caught misbehaving."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Fishermen"}),": These are permissionless verifier nodes external to the validator set. To participate as a Fishermen, they must stake a bond (default 0.1%) of the RollApp's liquidity pool tokens. This bond is slashable if they unjustifiably censor or reject a valid state transition that achieves consensus from other verifiers."]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"This combination of accountable Executors bound to their privilieged roles, along with permissionless external Verifiers staking economic bonds, upholds KIRA's security standards and robust crypto-economic incentives even for the off-chain Layer 2 computations."}),"\n",(0,n.jsx)(t.h3,{id:"4fdd27bada1342509f1976c7e4ccef66",children:"Enabling Features"}),"\n",(0,n.jsx)(t.p,{children:"To support building a rich ecosystem of RollApps, KIRA provides several enabling features:"}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Multi-Party Computation (MPC)"}),": For RollApps requiring cooperative multi-party computations (like random number generation or threshold signatures), Verifiers can participate by sending inputs alongside users to the Execution Container."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Token Issuance"}),": Each RollApp can issue its own token (with supply caps set by governance) to fund operations and pay rewards to Executors, Verifiers, and investors/developers."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Interoperability"}),": RollApps can potentially enable trustless cross-chain interoperability by issuing tokens representing assets on other chains and using MPC for threshold signature schemes."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Composability"}),": The secure SEKAI settlement layer can act as a trusted source of canonical state to enable composing multiple RollApps while avoiding complexities like re-entrancy issues."]}),"\n",(0,n.jsx)(t.p,{children:"Overall, KIRA's Layer 2 Pessimistic Rolldowns provide a flexible framework for building scalable yet secure decentralized applications, leveraging the benefits of Layer 1 settlement guarantees combined with scalable off-chain parallel execution validatedby decentralized economic incentives."}),"\n",(0,n.jsx)(t.p,{children:"Let me know if this updated overview comprehensively covers all the key points from the specifications or if you need any clarifications or additions."})]})}function h(e={}){const{wrapper:t}={...(0,a.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},5162:(e,t,i)=>{i.d(t,{Z:()=>o});i(7294);var n=i(6905);const a={tabItem:"tabItem_Ymn6"};var s=i(5893);function o(e){let{children:t,hidden:i,className:o}=e;return(0,s.jsx)("div",{role:"tabpanel",className:(0,n.Z)(a.tabItem,o),hidden:i,children:t})}},4866:(e,t,i)=>{i.d(t,{Z:()=>j});var n=i(7294),a=i(6905),s=i(2466),o=i(6550),r=i(469),l=i(1980),c=i(7392),d=i(12);function h(e){return n.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,n.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function p(e){const{values:t,children:i}=e;return(0,n.useMemo)((()=>{const e=t??function(e){return h(e).map((e=>{let{props:{value:t,label:i,attributes:n,default:a}}=e;return{value:t,label:i,attributes:n,default:a}}))}(i);return function(e){const t=(0,c.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,i])}function u(e){let{value:t,tabValues:i}=e;return i.some((e=>e.value===t))}function m(e){let{queryString:t=!1,groupId:i}=e;const a=(0,o.k6)(),s=function(e){let{queryString:t=!1,groupId:i}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!i)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return i??null}({queryString:t,groupId:i});return[(0,l._X)(s),(0,n.useCallback)((e=>{if(!s)return;const t=new URLSearchParams(a.location.search);t.set(s,e),a.replace({...a.location,search:t.toString()})}),[s,a])]}function f(e){const{defaultValue:t,queryString:i=!1,groupId:a}=e,s=p(e),[o,l]=(0,n.useState)((()=>function(e){let{defaultValue:t,tabValues:i}=e;if(0===i.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!u({value:t,tabValues:i}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${i.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const n=i.find((e=>e.default))??i[0];if(!n)throw new Error("Unexpected error: 0 tabValues");return n.value}({defaultValue:t,tabValues:s}))),[c,h]=m({queryString:i,groupId:a}),[f,b]=function(e){let{groupId:t}=e;const i=function(e){return e?`docusaurus.tab.${e}`:null}(t),[a,s]=(0,d.Nk)(i);return[a,(0,n.useCallback)((e=>{i&&s.set(e)}),[i,s])]}({groupId:a}),g=(()=>{const e=c??f;return u({value:e,tabValues:s})?e:null})();(0,r.Z)((()=>{g&&l(g)}),[g]);return{selectedValue:o,selectValue:(0,n.useCallback)((e=>{if(!u({value:e,tabValues:s}))throw new Error(`Can't select invalid tab value=${e}`);l(e),h(e),b(e)}),[h,b,s]),tabValues:s}}var b=i(2389);const g={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var v=i(5893);function y(e){let{className:t,block:i,selectedValue:n,selectValue:o,tabValues:r}=e;const l=[],{blockElementScrollPositionUntilNextRender:c}=(0,s.o5)(),d=e=>{const t=e.currentTarget,i=l.indexOf(t),a=r[i].value;a!==n&&(c(t),o(a))},h=e=>{let t=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const i=l.indexOf(e.currentTarget)+1;t=l[i]??l[0];break}case"ArrowLeft":{const i=l.indexOf(e.currentTarget)-1;t=l[i]??l[l.length-1];break}}t?.focus()};return(0,v.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,a.Z)("tabs",{"tabs--block":i},t),children:r.map((e=>{let{value:t,label:i,attributes:s}=e;return(0,v.jsx)("li",{role:"tab",tabIndex:n===t?0:-1,"aria-selected":n===t,ref:e=>l.push(e),onKeyDown:h,onClick:d,...s,className:(0,a.Z)("tabs__item",g.tabItem,s?.className,{"tabs__item--active":n===t}),children:i??t},t)}))})}function x(e){let{lazy:t,children:i,selectedValue:a}=e;const s=(Array.isArray(i)?i:[i]).filter(Boolean);if(t){const e=s.find((e=>e.props.value===a));return e?(0,n.cloneElement)(e,{className:"margin-top--md"}):null}return(0,v.jsx)("div",{className:"margin-top--md",children:s.map(((e,t)=>(0,n.cloneElement)(e,{key:t,hidden:e.props.value!==a})))})}function w(e){const t=f(e);return(0,v.jsxs)("div",{className:(0,a.Z)("tabs-container",g.tabList),children:[(0,v.jsx)(y,{...e,...t}),(0,v.jsx)(x,{...e,...t})]})}function j(e){const t=(0,b.Z)();return(0,v.jsx)(w,{...e,children:h(e.children)},String(t))}},1568:(e,t,i)=>{i.d(t,{Z:()=>n});const n=i.p+"assets/images/1202357394-25a5a3e07b8e1aeec254776b2dce1d13.png"},1559:(e,t,i)=>{i.d(t,{Z:()=>n});const n=i.p+"assets/images/1387519270-f8bdc91639c61225b10e7db1451f499c.png"},3539:(e,t,i)=>{i.d(t,{Z:()=>n});const n=i.p+"assets/images/506458943-526185fbc9ad54a4a973e11b397aed3d.png"},444:(e,t,i)=>{i.d(t,{Z:()=>n});const n=i.p+"assets/images/644648612-fe3a88122ab9344aa4d7e7a55f12298a.png"},3703:(e,t,i)=>{i.d(t,{Z:()=>n});const n=i.p+"assets/images/737920724-d7f4cdb8ce58ccb26bc5ad09f98d2b15.png"},1151:(e,t,i)=>{i.d(t,{Z:()=>r,a:()=>o});var n=i(7294);const a={},s=n.createContext(a);function o(e){const t=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);